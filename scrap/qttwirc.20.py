#qttwirc stands for Qt Twisted on Windows IRC
#note: PyQt requires a fee for commercial use, PySide doesn't and is largely similar
#todo:
#if no realname, etc. defined for the network in the json config, default to those defined on the general level.
#if all nicks defined for a network are taken, try nicks from "nicks" outside of any network in the config file
#when loading files like qttwirc.conf.json, load from the path of the loaded python file
#cycle through servers on connection fail
#copy.deepcopy config[network] when passing to factory
#find out how to make config class so that i can use .'s instead of [""]'s
#how do i show the server messages that are in green in mIRC
#keep scrollback below x lines
#identd
#if all alternative nicks are in use, popup a dialog asking for a nick
#input history 
#color codes input
#maybe irc commands that use server.serverconnection.* could just use server.*
#[4:15am] <mrvn> void QWidget::customContextMenuRequested ( const QPoint & pos ) [signal]
#[4:17am] <mrvn> When you get that signal you have to map the pos to global coordinates, create a QMenu and exec_() it there
#[4:17am] <mrvn> And you can use listWidget.itemAt(pos)
#find out why connection process hangs sometimes after "got ident response", or set a timeout, or something.
#make a networkusers class, so we don't have to set a nick's ident/hostmask on each channel when we discover it? and maybe other reasons, related to private messages?
#change nick in nicklist on mode update - http://www.geekshed.net/2009/10/nick-prefixes-explained/
#nickslist - don't let it keep a nick selected "item needs to be selectable. but you can style the qlistwidget with qss to make selected/normal appear same"
#use color for messages generated by the client (messages starting with *)
#move processing of commands to a separate function that is universal to server, channel and privmsg windows
#should channels be moved to server because they get erased as soon as it gets disconnected?
#make networks a dictionary
#change reconnectdelay so that it only applies to connecting to the same server again within x seconds after previous connect attempt 
#nick completion
#use fixedsys for ascii characters and excelsior for unicode. this could be a problem since excelsior sizes are different from fixedsys sizes. (e.g. 7 in fixedsys is 10 in excelsior.)
#group new channel tabs with the correct server tabs
#update user.ident, user.host, and MessageWindow for all connections having the same network name? 
#ctrl-tab and ctrl-shift-tab to switch between tabs. ctrl-f4 to part a channel
#change colors of tab labels if new messages in channels
#beep/change colors of tab labels if self.nickname mentioned in channel
#command to beep if new message in a given channel
#if privmsg from different nick, same ident@host as an open privmsg window, show in that window and do updates?
#need x buttons for windows
#dividers in tab_widget like in mIRC?
#fix "your host is, \n running version ..." <- seems there's no bug, it was a server glitch.
#once it joined channels and didn't populate the nicks lists at all.  mIRC never did that.
#start text on bottom of window like mIRC
#show connection lost in channels and messagewindows
#detect bad username error if possible - can anything be done about it?  
#select and copy doesn't seem to work right. must be a qt bug.
#ability to add a hook on an arbitrary event (including a timer event) during run-time from input.  options to do it once or every time, only in a certain channel or network, etc.
#have nicks, username, realname, ident able to be defined in config file outside of specific networks
#ability to act as a bouncer or a client for it
#fix updating of ident and host so that it doesn't look through the whole nick list of each channel each time
#make nick_lower function
#have a global user list for each network and point to those users from the channels instead of having an independent list of users for each channel?
#use User class
#have common names across qttwirc.py, irc.py and scripts
#i have both irc.usersplit (used by the trivia script) and qttmwirc.splithostmask (used other places). only one should be necessary, or at least make them both work the same.
#don't change network.mynick (and the other place it changes it) if setnick returns an error from the server
#trivia plugin - when entering commands from local, the result shows up before the command
#channels are showing up twice in the switchbar for some reason
#should probably use weakref in some places with all these circular references. i think python garbage-collects circular references but collecting them takes more resources than normal collection.
#change lowercase variables to camelCase
#if we make a lot of new connections and disconnect a lot of them, do we leak connection instances? I guess we leak them in the global list "networks".
#when cycling through nicks, first use nicks that are <= maxnicklen
#there are inconsistencies in naming objects. blahblah, blah_blah, and blahBlah.
#allow to have network info's in the config file that we don't automatically connect to. maybe have a startup script and a perform script for connecting? just pipe all the lines to docommand.
#are conn and serverconnection the same thing? should I remove conn?
#i changed a lot of .lower()'s to irclower()'s that I probably shouldn't have done. Also I used conn.irclower() so it'll berak if there's no conn.
#need to have a max size for the windows' scrollbacks. i guess take a byte offset in the scrollback and then find the next line break.
#add ctrl-tab and ctrl-shift-tab to shift between tabs
#change color of tab text according to channel activity like mIRC does 
#make a better way to autojoin channels and autoconnect to networks than performonstartup.py
#support SASL
#make network-wide Users dict and have channel.users point to users in that dict
#add logging and make it able to separate logs by week, month, and trim logs to a certain size
#when saving json use https://docs.python.org/3.2/library/pprint.html

from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtMultimedia import QSound
import json

import os, sys, time, re, itertools, traceback, copy, os

invalidwindowsfilenamestems = set(("CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9")) #case-insensitive
invalidwindowsfilenamecharsre = re.compile('[\\\/\:\*\?\"\<\>\u0000-\u001F]')

def getlogfilepath(stem, ext):
  stem = invalidwindowsfilenamecharsre.sub(stem, "_")
  if stem.upper() in invalidwindowsfilenamestems:
    stem += "_"
  return os.path.join(qttwircpath, stem + "." + invalidwindowsfilenamecharsre.sub(ext, "_") + ".log")

def runidentd():
  identf = protocol.ServerFactory()
  identf.protocol = identd
  try:
    reactor.listenTCP(113,identf)
  except:
    print("Could not run identd server.")
    #todo: show it in the gui 
  return identf

#if multiple lines inputted, detect if each line starts with "/" and run the command if it does?
class ServerInputQTextEdit(QTextEdit):
  def __init__(self, serverwindow):
    QTextEdit.__init__(self)
    self.serverwindow = serverwindow
    self.setAcceptRichText(False)
  def keyPressEvent(self, event):
    if event.key() == Qt.Key_Return:
      text = str(self.toPlainText())
      self.setPlainText("")
      if text.lstrip().startswith("/"):
        docommand("serverwindow", self.serverwindow, text)
      else:
        addline(self.serverwindow, self.serverwindow.server.network.name, "* Nothing performed. This is not a channel or private-message window")
        
    else:
      QTextEdit.keyPressEvent(self, event)
      
class ChannelInputQTextEdit(QTextEdit):         
  def __init__(self, channel):
    QTextEdit.__init__(self)
    self.channel = channel
    self.setAcceptRichText(False)

  def keyPressEvent(self, event):
    if event.key() == Qt.Key_Return and not (event.modifiers() and Qt.ShiftModifier):
      #text = str(self.toPlainText()) #doesn't work with unicode input
      text = unicode(self.toPlainText())
      self.setPlainText("")
      if text.lstrip().startswith("/"):
        docommand("channelwindow", self.channel.channelwindow, text)
      else:
        if self.channel.network.server.serverconnection:
          self.channel.network.server.serverconnection.msg(self.channel.name, text.encode("utf-8"))
          for msg in text.split(r"\n"): #todo: sure this should be a raw string? why did I do that? and if so, we need an escape for "\\" in case we need to do "\\n"
            addline(self.channel.channelwindow, "<%s> %s" % (self.channel.network.server.serverconnection.nickname, msg))
        else:
          addline(channel.channelwindow, self.channelwindow.channel.name + "." + self.channelwindow.network.name, "* You are not currently connected to a server") #does mIRC log responses like this that would be out of context without showing the input?
    else:
      QTextEdit.keyPressEvent(self, event)
      
def lookupnetworkconfig(name): #name = network or server name
  name = name.lower()
  for network_conf in config.networks:
    if network_conf.name.encode("ascii").lower() == name:
      return network_conf, True
  for server, port in network_conf.servers:
    if server.encode("ascii").lower() == name:
      return network_conf, False
  return None, True

def log(windowtype, window, text):
  if windowtype == "serverwindow":
    filestem = window.server.network.name
  elif windowtype == "channelwindow":
    filestem = window.channel.name + "." + window.server.network.name
  filepath = os.path.join(logspath, filestem + ".log")

def docommand(windowtype, window, text): #todo: test from server, channel, and privmsg
  params = text.split()   
  if params[0].lower() == "/join":
    if len(params) in (2, 3): #todo: /j for multiple channels
      if window.network.server.serverconnection:
        window.network.server.serverconnection.join(*params[1:]) 
      else:
        addline(window, filepath, "* You are not currently connected to a server")
    else:
      window.addline("* Usage: /join <channel> [key]")
  elif params[0].lower()=="/msg":
    dest = params[1]
    #print text
    message = text.split(None, 1)[1].split(" ", 1)[1]
    window.network.server.serverconnection.msg(dest, message)
  elif params[0].lower()=="/server":
    network_config = None
    switches = params.pop(1)[1] if params[1].startswith("-") else "" #todo: will break if param is simply "-"
    if len(params) > 3:
      window.addline("* Usage: /server [-m] [<server> [port]]")
      return
    if "m" in switches:
      serverwindow = ServerWindow()
      serverwindows.append(serverwindow)
      mainwin.tab_widget.setCurrentWidget(serverwindow.tab_index)
      network = Network(None, network_config)
      if len(params) == 1:
        network_config = copy.deepcopy(window.network.config)
      else:
        network_config, isbynetwork = lookupnetworkconfig(params[1])
      if len(params) == 1:
        if window.network and window.network.config and window.network.config.servername:
          network_config = window.network.config
        else:
          window.addline("* No server set for the current window and none specified.")
      else:
        network_config, isbynetwork = lookupnetworkconfig(params[1])
      window.network = network
      window.network.serverwindow = serverwindow      
    else:
      if len(params) == 1:
        window.network.conn.disconnect() #does connect() automatically do this so we don't need this line? does window.network necessarily have a .conn here?
        window.network.conn.connect()
        return
      else:
        network_config, isbynetwork = lookupnetworkconfig(params[1])
        if not network_config:
          window.network = Network()
          window.network.servername = params[1]
          if len(params) == 3:
            window.network.serverport = int(params[3])
          else:
            window.network.serverport = 6667 #should this be network.config.name and network.config.port instead? or maybe even put it in network_config? do I have name and port in network.config? I don't remember. not good to have these in three different places unnecessarily.
    temp_win = window.network.serverwindow if window.network and window.network.serverwindow else window
    mainwin.tab_widget.setTabText(temp_win.tab_index, network_config.name if network_config else params[1])
    username = network_config.username if network_config else config.username
    if username:
      username = username.encode("ascii")
    password = network_config.password if network_config else None
    if password:
      password = password.encode("ascii")
    if network_config: realname = network_config.realname
    realname = config.realname
    if realname:
      realname = realname.encode("ascii")
    network = Network()
    nick = network_config.nicks[0] if network_config and network_config.nicks else config.nicks[0] #in the newest typescript beta this would just be
                                                                                                   #nick = network.config.nicks?.[0] ?? config.nicks[0] or something like that.
                                                                                                   #wish python had that.
                                                                                                   #https://devblogs.microsoft.com/typescript/announcing-typescript-3-7-beta/
    realname = network_config.realname if network_config and network_config.realname else config.realname
    server = ServerFactory(nickname=nick.encode("ascii"), username=network_config.username.encode("ascii") if network_config and network_config.username else None,
                           password=network_config.password.encode("ascii") if network_config and network_config.password else None, realname=realname.encode("ascii") if realname else None,
                           network=network, network_config=network_config)
    
    print(f"server.nickname: {server.nickname}, server.username: {server.username}, server.password: {server.password}, server.realname: {server.realname}, server.network: {server.network}, server.network_config: {server.network_config}")  #debug
    
    
    window.network = network
    network.server = server
    server.network = network
    network.serverwindow = serverwindow if "m" in switches else (window if windowtype == "serverwindow" else window.network.serverwindow)
    network.serverindex = 0
    networks.append(network)
    if window.network and window.network.conn:
      window.network.conn.disconnect()
    if network_config:
      if isbynetwork:
        servername = network_config.servers[0][0] 
        port = network_config.servers[0][1]
      else:
        servername = params[1]
        port = int(params[2]) if len(params)>=2 else network_config.port if network_config.port else 6667
    else:
      servername = params[1]
      port = int(params[2]) if len(params) >= 3 else 6667 
    window.network.conn = reactor.connectTCP(servername, port, server)
    print("got here 2") #debug
  elif params[0].lower() == "/load": #todo: should be able to send parameters to the script
    if len(params) != 2:
      window.addline("* Usage: /load <name>")
    else:
      scripts[params[1]] = loadscript(params[1])
  else:
    window.addline("* Command not recognized")

class MessageInputQTextEdit(QTextEdit):
  def __init__(self, messagewindow):
    QTextEdit.__init__(self)
    self.messagewindow = messagewindow
    self.setAcceptRichText(False)

  def keyPressEvent(self, event):
    if event.key() == Qt.Key_Return and not (event.modifiers() and Qt.ShiftModifier):
      text = str(self.toPlainText())
      self.setPlainText("")
      if text.lstrip().startswith("/"):
        docommand("serverwindow", self.messagewindow, text)
      else:
        if self.messagewindow.network.server.serverconnection:
          self.messagewindow.network.server.serverconnection.msg(self.nick, text)
          for msg in text.split(r"\n"):
            self.messagewindow.addline("<%s> %s" % (self.messagewindow.network.server.serverconnection.nickname, msg))
        else:
          self.messagewindow.addline("* You are not currently connected to a server")
    else:
      QTextEdit.keyPressEvent(self, event)

def addline(window, *args): #should probably test if fn is None, not doing that until I have a use case though.
  flag = False
  for arg in args:
    #window.openlogfile.write(arg.encode("utf-8"))
    if flag:
      window.textwindow.insertHtml(arg)
    else:
      window.textwindow.insertPlainText(arg)
      window.openlogfile.write(arg.encode("utf-8"))
    flag = not flag
  window.openlogfile.write("\n")
  window.textwindow.insertHtml("<br>")
  window.textwindow.moveCursor(QTextCursor.End) #not sure this is necessary, it was in an example for doing this for some reason. (something about Qt adding extra newlines)
  scrollbar = window.textwindow.verticalScrollBar()
  scrollbar.setValue(scrollbar.maximum())

def addlinecolored(window, *args): #todo: remove the redundancy between addline for server windows and addline for channel windows and addline for message windows
  flag = False
  for arg in args:
    if flag:
      window.textwindow.insertHtml(arg)
    else:
      colorify(window.textwindow, arg)
      window.openlogfile.write(arg) #should make an option to leave colors out of log files.
    flag = not flag
  window.openlogfile.write("\n")
  window.textwindow.insertHtml("<br>")
  window.textwindow.moveCursor(QTextCursor.End) #not sure this is necessary, it was in an example for doing this for some reason.
  scrollbar = window.textwindow.verticalScrollBar()
  scrollbar.setValue(scrollbar.maximum())

class MessageWindow(QWidget):
  def __init__(self, network, nick):
    QWidget.__init__(self)
    self.network = network
    self.nick = nick
    mainwin.tab_widget.addTab(self, nick)
    self.textwindow = QTextEdit(self)
    self.textwindow.setReadOnly(True)
    self.textwindow.setFont(font)
    self.textwindow.setStyleSheet("* {position: absolute; bottom: 0}") #doesn't work
    self.layout = QVBoxLayout(self)
    self.layout.setContentsMargins(0, 0, 0, 0)
    self.layout.addWidget(self.textwindow)
    self.editwindow = MessageInputQTextEdit(self) 
    self.editwindow.setFont(font)
    self.layout.addWidget(self.editwindow)
    #sizepolicy = QSizePolicy()
    #sizepolicy.setVerticalPolicy()
    #self.editwindow.setSizePolicy(sizepolicy)
    self.editwindow.setFixedHeight(40)
    self.editwindow.setFocus()
    self.logfilepath = getlogfilepath(nick, network.name)
    self.openlogfile = open(self.logfilepath, "a")
  def __del__(self):
    self.openlogfile.close()
    
#class ChannelNicks(QTextEdit):
#  def __init__(self):
#    QTextEdit.__init__(self)
    
class User:
  def __init__(nick, network, ident=None, host=None, realname=None, channels=None, querywindow=None):
    self.nick = nick
    self.network = network
    self.ident = ident
    self.host = host
    self.realname = realname
    self.channels = channels
    self.message = messagewindow

  def joined(self, channelname):
    channelname_lower = self.server.serverconnection.irclower(channelname)
    channel = Channel(channelname, self.server.network)
    channelwindow = ChannelWindow(channel, self.server.network)
    channel.channelwindow = channelwindow
    self.server.network.channels[channelname_lower] = channel
    app.processEvents()
    sizes = channelwindow.splitter.sizes()
    channelwindow.splitter.setSizes([sum(sizes)-150, 150])
  
  # def irc_RPL_WELCOME(self, prefix, params): #actually we should be doing this in irc_RPL_ISUPPORT (NETWORK=). do both? do all irc servers send ISUPPORT NETWORK=?
  #   if params[1].startswith("Welcome to the "):
  #     networkname = params[1].split()[3] #do network names ever have more than one word in them? i'm only capturing one word because i saw both "irc network" and "internet chat relay network" after this word
  #     oldnetworkname = getattr(self.server.network, name, None) #should networkname go under network, server or serverconnection? 
  #     self.server.network.name = networkname #should we detecte a network change on reconnect in irc_RPL_WELCOME or in irc_RPL_ISUPPORT? we shouldn't do both because a network could give slightly different results for those two things.
  #     if oldnetworkname and (networkname.lower() != oldnetworkname.lower()): #calling .lower here is the Right Thing to do, right? 
  #       self.changednetworks(oldnetworkname, networkname)
  #       #todo: we may also want to do something if networkname.lower() != self.server.network.config["name"].lower()

  def irc_RPL_ISUPPORT(self, prefix, params):
    for param in params[1:]:
      keyvalue = param.split("=",1)
      if len(keyvalue) == 2:
        self.server.network.isupport[keyvalue[0]]=keyvalue[1]
      else:
        self.server.network.isupport[keyvalue[0]]=None
      if keyvalue[0] == "NETWORK":
        networkname = keyvalue[1] #ISUPPORT NETWORK without an =somevalue will cause an exception but who cares. exceptions are eaten, and why would a server do that?
        oldnetworkname = getattr(self.server.network, name, None) 
        self.server.network.name=networkname
        mainwin.tab_widget.setTabText(self.server.network.serverwindow.tab_index, networkname)
        if oldnetworkname and (networkname.lower() != oldnetworkname.lower()): #calling .lower here is the Right Thing to do, right? 
          self.changednetworks(oldnetworkname, networkname)
  #       #todo: we may also want to do something if networkname.lower() != self.server.network.config["name"].lower()

  def changednetworks(self, oldnetworkname, newnetworkname): #should probably rename this to networkchanged to make it more consistent
    for channel in self.network.channels.iterValues():
      channel.channelwindow.deleteLater()
    self.network.channels = {}
    for messagewindow in self.network.messagewindows.iterValues():
      messagewindow.deleteLater()
    self.network.messagewindows = {}
    self.serverwindow.openlogfile.close()
    self.serverwindow.logfilepath = getlogfilepath("status", network.name)
    self.serverwindow.openlogfile = open(self.logfilepath, "a")
    
  def irc_RPL_NAMREPLY(self, prefix, params):
    channelname_lower = self.server.serverconnection.irclower(params[2])
    for nick in params[3].split():
      nmo = re.match(r"([^a-zA-Z_[\]{}^`|]*).*", nick) #numbers and - can't be first character of a nick
      np = nick[:nmo.end(1)]
      nwp = nick[nmo.end(1):]
      nwp_lower = nwp.lower() #what is nwp. should I be using irclower() here?
      user = User(nwp, prefix=np)
      channel = self.server.network.channels[channelname_lower]
      channel.users[nwp_lower] = user
      #self.server.channels[channelname_lower].channelwindow.nickslist.insertHtml(nick + "<br>")
      item = NickItem(nick, user)
      channel.channelwindow.nickslist.addItem(item)
      channel.users[nwp_lower].item = item
      
  def irc_ERR_NICKNAMEINUSE(self, prefix, params):
    if not self.signedon: #should test if this is correct.
      oldnick = self.server.network.config["nicks"][self.nickindex]
      self.nickindex = (self.nickindex+1) % len(self.server.network.config["nicks"])
      newnick = self.server.network.config["nicks"][self.nickindex].encode("ascii")
      addline(self.server.network.serverwindow, '* Nick "%s" is taken. Changing nick to "%s"' % (oldnick, newnick))
      self.setNick(newnick)
      self.network.mynick = newnick
      self.nickname = newnick #do i have to do this?
    else:
      addline(self.server.network.serverwindow, ' * Nick "%s" already in use' % XXX)#todo: find out where %s is in the params
      
  def irc_ERR_ERRONEUSNICKNAME(self, prefix, params):
    if not self.signedon: #should test if this is correct.
      oldnick = self.server.network.config["nicks"][self.nickindex]
      self.nickindex = (self.nickindex+1) % len(self.server.network.config["nicks"])
      newnick = self.server.network.config["nicks"][self.nickindex].encode("ascii")
      addline(self.server.network.serverwindow, '* Nick "%s" is taken. Changing nick to "%s"' % (oldnick, newnick)) #todo: use oldnick from params instead of config.
      self.setNick(newnick)
      self.nickname = newnick #do i have to do this?
    else:
      addline(self.server.network.serverwindow, ' * "%s" is an invalid nick' % XXX)#todo: find out where %s is in the params
      

class ServerWindow(QWidget):
  def __init__(self, network=None):
    QWidget.__init__(self)
    self.network = network
    self.tab_index = mainwin.tab_widget.addTab(self, network.config.name if network else "Server window")
    self.textwindow = QTextEdit(self)
    self.textwindow.setReadOnly(True)
    self.textwindow.setFont(font)
    self.textwindow.setStyleSheet("* {position: absolute; bottom: 0}") #doesn't work
    self.layout = QVBoxLayout(self)
    self.layout.setContentsMargins(0, 0, 0, 0)
    self.layout.addWidget(self.textwindow)
    self.editwindow = ServerInputQTextEdit(self) 
    self.editwindow.setFont(font)
    self.layout.addWidget(self.editwindow)
    #sizepolicy = QSizePolicy()
    #sizepolicy.setVerticalPolicy()
    #self.editwindow.setSizePolicy(sizepolicy)
    self.editwindow.setFixedHeight(40)
    self.editwindow.setFocus()
    self.logfilepath = getlogfilepath("status", network.name if network else "")
    self.openlogfile = open(self.logfilepath, "a")
  def __del__(self):
    self.openlogfile.close()

def newserverwindow():
  serverwindow = ServerWindow()
  serverwindows.append(serverwindow)
      
class Channel:
  def __init__(self, channelname, network, channelwindow=None):
    self.name = channelname
    self.users = {}
    self.network = network
    self.network.channels[network.server.serverconnection.irclower(channelname)] = self
    self.channelwindow = channelwindow
  #def adduser(nick, prefix=None, hostmask=None):
  #  self.users[nick] = ChannelUser(nick, prefix, hostmask)
  #  self.channelwindow.nickslist.setHtml("<br>".join(sorted(self.users.keys()))) #fortunately nicks can't have < or > in them. if i weren't lazy i would replace them anyway with &lt or whatever (assuming pyqt even supports that)
  def adduser(self, nick):
    self.users.add(nick)
    self.updateuserlist()
  def removeuser(self, nick):
    self.users.remove(nick)
    self.updateuserlist()
  def updateuserlist(self):
    self.channelwindow.nicks.setText('\n'.join(sorted(self.nicks)))
    #todo: nick formatting options, sorting by status options, right-clickable, hoverable, size according to longest nick option (can we even do this?)
  def post(self, message):
    self.network.server.serverconnection.say(self.name, message) #todo: length check
    self.channelwindow.addlinecolored("<%s> %s" % (self.network.mynick, message))
  def rejoined(self):
    pass #todo
    
class User:
  def __init__(self, nick, prefix=None, ident=None, host=None, realname=None, server=None, loggedinas=None, onchannels=None):
    self.prefix = prefix
    self.host = host
    self.nick = nick
    self.ident = ident
    self.realname = None
    self.servername = None
    self.loggedinas = None
    self.onchannels = None
      
class ChannelWindow(QWidget):
  def __init__(self, channel, network):
    QWidget.__init__(self)
    self.tab_index = mainwin.tab_widget.addTab(self, channel.name)
    mainwin.tab_widget.setCurrentIndex(self.tab_index)
    self.channel = channel
    self.splitter = QSplitter(self)
    self.nickslist = QListWidget(self)
    self.nickslist.setSortingEnabled(True)
    self.nickslist.setFont(font)
    #self.nickslist.setReadOnly(True) #in case we change this back to a QTextEdit
    self.textwindow = QTextEdit(self)
    self.textwindow.setReadOnly(True)
    self.textwindow.setFont(font)
    self.textwindow.setStyleSheet("* {position: absolute; bottom: 0}")
    self.splitter.addWidget(self.textwindow)
    self.splitter.addWidget(self.nickslist)
    self.network = network
    self.vlayout = QVBoxLayout(self)
    self.vlayout.setContentsMargins(0, 0, 0, 0)
    self.vlayout.addWidget(self.splitter)
    self.editwindow = ChannelInputQTextEdit(channel)
    self.editwindow.setFont(font)
    self.vlayout.addWidget(self.editwindow)
    nickswidth = self.nickslist.width()
    textwidth = self.textwindow.width()
    self.editwindow.setFixedHeight(40)
    self.editwindow.setFocus()
    self.logfilepath = getlogfilepath(self.channel.name, network.name)
    self.openlogfile = open(self.logfilepath, "a")
  def __del__(self):
    self.openlogfile.close()
  
class NickItem(QListWidgetItem):
  def __init__(self, nick, user):
    QListWidgetItem.__init__(self, nick)
    self.user = user
  def __lt__(self, other):
    return self.text().toLower() < other.text().toLower() #todo: is "@" < "+"? cuz we want ops on top.
  
class Network(object):
  def __init__(self, server=None, network_config=None, mynick=None, serverwindow=None):
    self.conn = None
    self.server = server
    self.isupport = {}
    self.config = network_config
    self.channels = {}
    self.mynick = mynick
    self.name = None
    self.messagewindows = {} #should this be another class whose objects have messagewindow as an attribute? and if so, what would i call the class?
    self.serverwindow = serverwindow
        
def splithostmask(hostmask):
  if "!" in hostmask:
    nick, rest = hostmask.split("!", 1)
  else:
    nick, rest = hostmask, ""
  if "@" in rest:
    ident, host = rest.split("@", 1)
  else:
    ident, host = "", ""
  return nick, ident, host

colorre = re.compile("(?:\x03(?:\\d\\d?(?:,\\d\\d?)?)?)|\x02|\x1f|\x16|\x1d")
#irccolors = ["#FFFFFF",    "#000000", "#00007F",   "#009300",    "#FF0000",   "#7F0000",  "#9C009C",      "#FC7F00",
#              "#FFFF00",    "#00FC00",   "#009393",   "#00FFFF",     "#0000FC", "#FF00FF",     "#7F7F7F",      "#D2D2D2"]
irccolors = ((255,255,255), (0, 0, 0), (0, 0, 127), (0, 147, 00), (255, 0, 0), (127, 0, 0), (156, 0, 156), (252, 127, 0),
             (255,255,0), (0, 252, 0), (0, 147, 147), (0, 255, 255), (0, 0, 252), (255, 0, 255), (127, 127, 127), (210, 210, 210))
#irccolors = ["White", "Black", "Navy Blue", "Green", "Red", "Brown", "Purple", "Olive", "Yellow", "Lime Green", "Teal", "Aqua Light", "Royal Blue", "Hot Pink", "Dark Gray", "Light Gray"]
# actual names of colors from http://www.ircbeginner.com/ircinfo/colors.html - untested

def colorify(widget, msg): #should behave just like mIRC.
  matches = re.findall(colorre, msg)
  texts = re.split(colorre, msg)
  bold = False
  underline = False
  italics = False
  reversed = False
  origcolorf = widget.textColor()
  #origcolorb = widget.textBackgroundColor() #doesn't fucking work
  origcolorb = QColor(255, 255, 255) #todo: get this value from configuration, if we add a configuration option for this.  also, report a bug re textBackgroundColor. i think qt4 support is discontinuing december 2015.
  curcolorf = origcolorf
  curcolorb = origcolorb
  for (text, code) in itertools.izip_longest(texts, matches): 
    widget.insertPlainText(text)
    if code:
      if code == "\x02":
        bold = not bold
        widget.setFontWeight(QFont.Bold if bold else QFont.Normal) 
      elif code == "\x1f":
        underline = not underline
        widget.setFontUnderline(underline)
      elif code == "\x1d":
        italics = not italics
        widget.setFontItalic(italics)
      elif code == "\x16":
        reversed = not reversed
        if reversed:
          widget.setTextColor(origcolorb)
          widget.setTextBackgroundColor(origcolorf)
        else:
          widget.setTextColor(curcolorf)
          widget.setTextBackgroundColor(curcolorb)
      elif code[0] == "\x03":
        if code == "\x03":
          curcolorf = origcolorf
          curcolorb = origcolorb
          if not reversed:
            widget.setTextColor(curcolorf)
            widget.setTextBackgroundColor(curcolorb)
        else:
          codes = code[1:].split(",")
          curcolorf = QColor(*irccolors[int(codes[0])])
          widget.setTextColor(curcolorf)
          if len(codes) == 2:
            curcolorb = QColor(*irccolors[int(codes[1])])
            widget.setTextBackgroundColor(curcolorb)
  widget.setTextColor(origcolorf)
  widget.setTextBackgroundColor(origcolorb)

     
def json_to_namespaces(b):
  if type(b) == list:
    o = []
    for e in b:
      o.append(json_to_namespaces(e))
  elif type(b) == dict:
    class O(object):
      def __init__(self, d):
        self.d = d
      def __getattr__(self, attr):
        if attr in self.d:
          return json_to_namespaces(self.d[attr])
        else:
          return None
    o = O(b)
  #elif type(b) in (unicode, int, float):
  else:
    o = b
  return o

class Script: 
  def __init__(self, module, script):
    self.module = module
    self.script = script

def loadscript(scriptfn):
  scriptpath = os.path.join(scriptspath, scriptfn)
  if scriptfn.lower().endswith(".py"):
    scriptname = scriptfn[:-3]
  elif os.path.isdir(scriptpath):
    if os.path.exists(os.path.join(scriptpath, "__init__.py")):
      scriptname = scriptfn
  try:
    __import__("scripts."+scriptname)
    scriptmodule = sys.modules["scripts."+scriptname]
    script = Script(scriptmodule, scriptmodule.Script(networks, serverwindows, docommand))
  except Exception as inst:
    raise #debug
    print('Could not load script "%s" from "%s" because of error: %s' % (scriptname, scriptpath, inst.message))
    #todo: gui
  return script 

# def loadscripts():
#   scripts = {}
#   for scriptfn in os.listdir(os.path.join(mypath, "scripts")):
#     if not scriptfn.startswith("_"):
#       scriptpath = os.path.join(scriptspath, scriptfn)
#       if scriptfn.lower().endswith(".py"):
#         scriptname = scriptfn[:-3]
#       elif os.path.isdir(scriptpath):
#         if os.path.exists(os.path.join(scriptpath, "__init__.py")):
#           scriptname = scriptfn
#       try:
#         __import__("scripts."+scriptname)
#         script = sys.modules["scripts."+scriptname]
#         scripts[scriptname] = Script(script, script.Script(networks))
#         
#         
#       except Exception, inst:
#         raise #debug
#         print 'Could not load script "%s" from "%s" because of error: %s' % (scriptname, scriptpath, inst.message)
#         #todo: gui
#   return scripts

def makefunc(name, obj):#one way to do closure in Python
  def f(self, *args, **kwargs): 
    for script in scripts.itervalues():
      obj2 = getattr(script.script, name, None)
      try:
        if obj2 and obj2(self, *args, **kwargs):
          break
      except:
        traceback.print_exc()
    else:
      return obj(self, *args, **kwargs)
  return f
  
def clickable(widget):
  class Filter(QObject):
    clicked = pyqtSignal()
    def eventFilter(self, obj, event):
      if obj == widget:
        if event.type() == QEvent.MouseButtonRelease:
          if obj.rect().contains(event.pos()):
            self.clicked.emit()
            # The developer can opt for .emit(obj) to get the object within the slot.
            return True
              
      return False
      
  filter = Filter(widget)
  widget.installEventFilter(filter)
  return filter.clicked

class MainWindow(QMainWindow):
  
  def __init__(self):
    QMainWindow.__init__(self)
    self.setWindowTitle("qttmwirc")
    self.mainmenu = self.menuBar()
    self.closetab = QLabel()
    self.restoretab = QLabel()
    self.minimizetab = QLabel()
    self.minimizetab.setPixmap(QPixmap("minus-box_318-27566.jpg").scaledToWidth(20))
    self.restoretab.setPixmap(QPixmap("download.png").scaledToWidth(20))
    self.closetab.setPixmap(QPixmap("cross-remove-sign_318-75006.jpg").scaledToWidth(20))
    self.hlayout = QHBoxLayout()
    self.hlayout.addWidget(self.minimizetab)
    self.hlayout.addWidget(self.restoretab)
    self.hlayout.addWidget(self.closetab)
    clickable(self.minimizetab).connect(self.doMinimizeTab)
    self.minimizerestoreclose = QWidget()
    self.minimizerestoreclose.setLayout(self.hlayout)
    self.mainmenu.setCornerWidget(self.minimizerestoreclose, Qt.TopRightCorner)
    self.minimizerestoreclose.show() 
    #self.mainmenu.setCornerWidget(self.test2, Qt.TopRightCorner) #debug
    
    self.extractAction = QAction("&Exit", self)
    self.extractAction.triggered.connect(self.closeEvent)
    self.fileMenu = self.mainmenu.addMenu('&File')
    self.mnunew = self.fileMenu.addMenu("&New")
    self.fileMenu.addAction(self.extractAction)
    self.newclientaction = QAction("&Server window", self)
    self.newclientaction.triggered.connect(newserverwindow)
    self.mnunew.addAction(self.newclientaction)
    self.tab_widget = QTabWidget()
    self.vbox = QVBoxLayout() 
    self.vbox.addWidget(self.tab_widget)
    self.vbox.setContentsMargins(0, 0, 0, 0)
    self.setCentralWidget(self.tab_widget)
    self.showMaximized()

  
  #def close_application(self):
  #  reactor.stop()
  #  sys.exit()
    
  def closeEvent(self, event):
    QCoreApplication.instance().quit()
    
  def doMinimizeTab(self):
    #print "test" #debug
    pass
  
  
serverwindows = [] 
# 
# class MainWindow(QMainWindow):
# def __init__(self):
#   super(MainWindow, self).__init__()
#   self.initUI()
#   
# def initUI(self):
#   self.workspace = QMdiArea()
#   self.showMaximized()
# 
# def closeEvent(self, event):
#     QCoreApplication.instance().quit()

if __name__ == '__main__':

  def stop():
    print("Stop")
    if reactor.running:
      reactor.stop()

  app = QApplication(sys.argv)
  import qt5reactor
  qt5reactor.install()
  from twisted.internet import reactor
  #window = MainWindow()
  #window.show()
  app.lastWindowClosed.connect(stop)
 # reactor.run()
  
  #from twistedclient import SocketClientFactory
  #from twisted.words.protocols import irc
  
  qttwircpath = os.path.dirname(os.path.abspath(__file__))
  scriptspath = os.path.join(qttwircpath, "scripts")
  logspath = os.path.join(qttwircpath, "logs") #maybe make this configurable in the future


  
#  path = os.path.join(os.path.split(sys.executable)[0], "Lib","site-packages","pywin32_system32")
#  os.environ["PATH"] = os.environ["PATH"] + ";" + path

  #app.lastWindowClosed.connect(app.quit)
  
  mainwin = MainWindow()
  #mainwin.mnunewclient.connect(mainwin.mnunewclient, SIGNAL('triggered()'), newclient)
#  mainwin.showMaximized()
  
  networks = []
   
  font = QFont("Fixedsys Excelsior 3.01 NoLiga")
  #font = QFont("Arial")
  #font = QFont("Fixedsys") 
  #font.setPointSize(7) #fixedsys
  font.setPointSize(10) #fixedsys excelsior
  ding = QSound(r"sounds\01_ECHOBEL3.wav") #todo: find out how to get directory of this running python file and os.join that with sounds\whatever
  
  serverwindow = ServerWindow(network=None)
  serverwindows.append(serverwindow)
    
  #mainwindow = MainWindow()
  
  #mainwindow.showMaximized()
  
  scripts = {}
  
  config = json_to_namespaces(json.load(open(os.path.join(qttwircpath, "qttwirc.conf.json")))) #todo: allow to specify config and performs in command-line options
#  for line in open(os.path.join(qttwircpath, "performonstartup.txt")): #should we make perform scripts more like scripts in the scripts directory to give them programmability?
#    line = line.rstrip()
#    docommand("serverwindow", serverwindow, line)
    
  reactor.run()
  
import irc
from twisted.internet import protocol

class ServerConnection(irc.IRCClient):
  
  def __init__(self):
    self.signedon = False
    self.nickindex = 0
  
  def signedOn(self):
    #print "signed on"
    addline(self.server.network.serverwindow, "* You are now signed on.")
    self.signedon = True
    mainwin.tab_widget.setTabText(mainwin.tab_widget.indexOf(self.server.network.serverwindow), "%s - %s" % (self.server.network.name, self.nickname)) #might be better to store the index
    
  def IRCcommand(self, command, prefix, params): #relies on a change to irc.py
    #print [command, prefix, params]
    #addline(self.server.network.serverwindow, repr([command, prefix, params])) #debug
    #if command not in ("PING", "PONG", "MODE", "RPL_NAMREPLY", "RPL_ENDOFNAMES", "JOIN", "RPL_TOPIC", "333"): #todo: handle notice and add it to this list. and of course, only show params
    addline(self.server.network.serverwindow, ' '.join(params[1:]))
      
  def nickChanged(self, newnick):
    self.nickname = newnick
    addline(self.server.network.serverwindow, "* Your nick has been changed to " + newnick)
    mainwin.tab_widget.setTabText(mainwin.tab_widget.indexOf(self.server.network.serverwindow), "%s - %s" % (self.server.network.config["name"], self.nickname)) #might be better to store the index
    for channel in self.server.network.channels.values():
      addline(channel.channelwindow, "* Your nick has been changed to " + newnick)
    for messagewindow in self.server.network.messagewindows:
      addline(messagewindow, "* Your nick has been changed to " + newnick)
      
  def kickedFrom(self, channelname, kicker, message):
    channels = self.server.network.channels
    channel = channels[self.server.serverconnection.irclower(channelname)]
    nick, ident, host = splithostname(kicker)
    addline(channel.channelwindow, "* You were kicked from %s by %s (%s@%s) for reason: %s" % (channelname, nick, ident, host, message))
    for user in [user for user in channel.users.values() for channel in channels.values() if user.nick==nick]:
      if ident: user.ident = ident
      if host: user.host = host
    nickslist = channel.nickslist
    for (nick_lower, user) in channel.users.iteritems():
      nickslist.takeItem(nickslist.row(user.item))
      del channel.users[nick_lower]
 
  def userKicked(self, kickednick, channelname, kicker, message):
    kickernick, kickerident, kickerhost = splithostmask(kicker)
    kickednick_lower = self.server.serverconnection.irclower(kickednick)
    for user in [user for user in channel.users.values() for channel in channels.values() if user.nick==kickernick]:
      if kickerident: user.ident = kickerident
      if kickerhost: user.host = kickerhost
    channel = self.server.network.channels[self.server.serverconnection.irclower(channelname)]
    addline(channel.channelwindow, "* %s was kicked from %s by %s (%s@%s) for reason: %s" % (kickednick, channelname, kickernick, kickerident, kickerhost, message))
    nickslist = channel.channelwindow.nickslist
    nickslist.takeItem(nickslist.row(channel.users[kickednick_lower].item))
    del channel.users[kickednick_lower]
 
  def userRenamed(self, oldnick, newnick):
    oldnick_lower = self.server.serverconnection.irclower(oldnick)
    for channel in self.server.network.channels.values():
      if oldnick_lower() in channel.users:
        user = channel.users[oldnick_lower]
        channel.users[self.server.serverconnection.irclower(newnick)] = user
        del channel.users[oldnick_lower]
        user.nick = newnick
        user.item.setText(user.prefix + newnick)
        addline(channel, "* %s is now %s" % (oldnick, newnick))
    if oldnick_lower in self.server.network.messagewindows:
      messagewindows = self.server.network.messagewindows
      messagewindow = messagewindows[oldnick_lower]
      messagewindows[self.server.serverconnection.irclower(newnick)] = messagewindow
      del messagewindows[oldnick_lower]
      mainwin.tab_widget.setTabText(mainwin.tab_widget.indexOf(self), newnick) #might be better to store the index
      addline(messagewindow, "* %s is now %s" % (oldnick, newnick))

  def privmsg(self, fromhostmask, msg):
    nick, ident, host = splithostmask(fromhostmask)
    msg = QString.fromUtf8(msg)
    fromnick_lower = self.server.serverconnection.irclower(nick)
    if fromnick_lower not in self.server.network.messagewindows:
      self.server.network.messagewindows[fromnick_lower] = MessageWindow(self.server.network, nick)
      ding.play()
    messagewindow = self.server.network.messagewindows[fromnick_lower]
    addlinecolored(messagewindow, "<%s> %s" % (nick, msg))
          
  def chanmsg(self, fromhostmask, target, msg):
    target_lower = self.server.serverconnection.irclower(target)
    nick, ident, host = splithostmask(fromhostmask)
    msg = QString.fromUtf8(msg)
    if target_lower in self.server.network.channels:
      channel = self.server.network.channels[target_lower]
      nick, ident, host = splithostmask(fromhostmask)
      #addline(channel.channelwindow, "<%s> %s" % (nick, msg))
      colorify(channel.channelwindow.textwindow, "<%s> %s" % (nick, msg))
      addline(channel.channelwindow, "") 
      if self.server.serverconnection.irclower(nick) in channel.users: #i think ircops can sometimes hang out invisible and speak
        user = channel.users[self.server.serverconnection.irclower(nick)]
        user.nick = nick
        if ident: user.ident = ident
        if host: user.host = host
    
  def userJoined(self, hostmask, channelname): #relies on a change to irc.py
    nick, ident, host = splithostmask(hostmask)
    nick_lower = self.server.serverconnection.irclower(nick)
    channels = self.server.network.channels
    channel = channels[self.server.serverconnection.irclower(channelname)]
    addline(channel.channelwindow, "* %s (%s@%s) has joined %s" % (nick, ident, host, channel.name))
    user = network.users.get(nick_lower, User(nick))
    network.users[nick_lower] = user
    #channel.users[self.conn.nick.lower()] = user #wtf why am i setting it to myself, fixing this
    item = NickItem(nick, user)
    user.item = item
    for user in [user for user in channel.users.values() for channel in channels.values() if user.nick==nick]:
      if ident: user.ident = ident
      if host: user.host = host
 
  def userLeft(self, hostmask, channelname):
    nick, ident, host = splithostmask(hostmask)
    nick_lower = self.server.serverconnection.irclower(nick)
    channel = self.server.network.channels[channelname.lower()]
    addline(channel.channelwindow, "* %s (%s@%s) has left %s" % (nick, ident, host, channel.name))
    nickslist = channel.channelwindow.nickslist
    nickslist.takeItem(nickslist.row(channel.users[nick_lower].item))
    del channel.users[nick_lower]
 
  def userQuit(self, hostmask, quitmsg):
    nick, ident, host = splithostmask(hostmask)
    nick_lower = self.server.serverconnection.irclower(nick)
    for channel in self.server.network.channels.values():
      if nick_lower in channel.users.keys(): #not sure it's safe to modify the dict while iterating over it but using .keys() should be fine
        addline(channel.channelwindow, "* %s (%s@%s) has quit IRC: %s" % (nick, ident, host, quitmsg))
        nickslist = channel.channelwindow.nickslist
        nickslist.takeItem(nickslist.row(channel.users[nick_lower].item))
        del channel.users[nick_lower]
    messagewindow = self.server.network.messagewindows.get(nick_lower)
    if messagewindow:
      addline(messagewindow, "* %s (%s@%s) has quit IRC: %s" % (nick, ident, host, quitmsg))
    
  def modeChanged(self, hostmask, channelname, added, removed): #problem: displaying mode changes the way i do may mislead users about how one *sets* modes.
    channel = self.server.network.channels.get(self.server.serverconnection.irclower(channelname))
    nick, ident, host = splithostmask(hostmask)
    if channel is not None:
      nmd = {"q": "~", "a": "&", "o": "@", "h": "%", "v": "+"} #is this the way a *real* irc client updates nicks in the nick list upon mode change?
      mctexts = []
      for mc in added:
        if mc[1]:
          mctexts.append("+%s %s" % mc)
          nickprefix = nmd.get(mc[0])
          if nickprefix:
            user = channel.users.get(self.server.serverconnection.irclower(mc[1]))
            if user: #something is wrong if user is None, but i'm not just asssuming it won't be because then if it is the mode changes won't be shown in channel, and also it won't process the rest of the mode changes.
              user.prefix = nickprefix
              user.item.setText(nickprefix + mc[1])
        else:
          mctexts.append("+" + mc[0])
      for mc in removed:
        if mc[1]:
          mctexts.append("-%s %s" % mc)
          nickprefix = nmd.get(mc[0])
          if nickprefix:
            user = channel.users.get(self.server.serverconnection.irclower(mc[1]))
            if user: #something is wrong if user is None, but i'm not just asssuming it won't be because then if it is the mode changes won't be shown in channel, and also it won't process the rest of the mode changes.
              if user.prefix == nickprefix:
                user.prefix = ""
                user.item.setText(mc[1])
        else:
          mctexts.append("-" + mc[0])
      addline(channel.channelwindow, "* %s sets mode(s): %s" % (nick, ", ".join(mctexts)))
      user = channel.users[self.server.serverconnection.irclower(nick)]
      if ident: user.ident = ident
      if host: user.host = host
    else:
      if channelname == self.nickname:
        mctexts = []
        for mc in added:
          if mc[1]:
            mctexts.append("+%s %s" % mc)
          else:
            mctexts.append("+" + mc[0])
        for mc in removed:
          if mc[1]:
            mctexts.append("-%s %s" % mc)
          else:
            mctexts.append("-" + mc[0])
        addline(self.server.network.serverwindow, "* %s sets mode(s): %s" % (nick, ", ".join(mctexts)))
      else:
        print("error: mode changes but target not recognized as a channel i'm in or as my own nick.  channelname: \"%s\"; self.nickname: \"%s\"" % (channelname, self.nickname))

class ServerFactory(protocol.ReconnectingClientFactory):
  def __init__(self, nickname="qttwirc", password=None, username="qttwirc", realname=None, network=None, network_config=None):
    self.network = network
    self.network_config = network_config
    self.network.mynick = nickname
    self.nickname = nickname
    self.username = username
    self.password = password
    self.realname = realname
    protocol.ReconnectingClientFactory.initialDelay = 10 #should i leave this at 1?
    protocol.ReconnectingClientFactory.maxDelay = 10 #no idea what value this should be. 3.5 wasn't slow enough, i was being throttled.
    
  def startedConnecting(self, connector):
    print("did this 5") #debug
    pass
  
  def buildProtocol(self, addr):
    p = ServerConnection()
    self.serverconnection = p
    p.server = self
    p.nickname = self.nickname
    p.username = self.username
    self.resetDelay()
    return p

  def clientConnectionLost(self, connector, reason):
    """If we get disconnected, reconnect to server."""
    self.serverconnection = None
    addline(self.network.serverwindow, "* Disconnected. Reconnecting...")
    #reactor.callLater(config.reconnectdelay, connector.connect)
    for channel in self.network.channels.values():
      channel.channelwindow.nickslist.clear()
    #self.network.channels = {} #todo: maybe we shouldn't do this because the windows are still open. just empty the users.
    protocol.ReconnectingClientFactory.clientConnectionLost(self, connector, reason)

    #connector.connect()
    
  def clientConnectionFailed(self, connector, reason):
    self.serverconnection = None
    if self.network_config:
      oldaddr, oldport = self.network_config.servers[self.network.serverindex] if self.network_config else None, None
      self.network.serverindex = (self.network.serverindex+1) % len(self.network_config.servers) #todo: make it actually use these values
      addr, port = self.network_config.servers[self.network.serverindex]

    #print "oldaddr:", oldaddr
    #print "oldport:", oldport
    #print "addr:", addr
    #print "port:", port

      addline(self.network.serverwindow, "* Connection to (%s, %d) failed. Connecting to (%s, %d)..." % (oldaddr, oldport, addr, port)) #todo: add reason for fail

      
      print("did this 4") #debug
      
    #reactor.callLater(config.reconnectdelay, reactor.connectTCP, addr.encode("ascii"), port, self)
      reactor.connectTCP(addr, port, self) #is this feasible? i don't know a better way to do this. connector.connect() apparently doesn't take server/port as arguments.
    
    else:
      
      print("did this 3") #debug
      
      addline(self.network.serverwindow, "* Connection to (%s, %d) failed. Reconnecting..." % (oldaddr, oldport, addr, port)) #todo: add reason for fail
        
    ##why did this break #todo: fix
    #for script in activescripts:
    #  
    #  obj = getattr(script.script, name, None)
    #  try:
    #    if obj and obj(self, connector.factory, reason): #connector.factory works?
    #      break
    #  except:
    #    traceback.print_exc()
          
    protocol.ReconnectingClientFactory.clientConnectionFailed(self, connector, reason)

class identd(protocol.Protocol):
  def dataReceived(self, data):
    self.transport.write(data.strip() + " : USERID : UNIX : " + config.identid + "\r\n" )
    #todo: configure id per network

if __name__=="__main__":
  for name in dir(ServerConnection):
    if not name.startswith('_'):
      obj = getattr(ServerConnection, name)
      if callable(obj):
        setattr(ServerConnection, name, makefunc(name, obj))

  for command in config.performonstartup:
    docommand("serverwindow", serverwindow, command)

  identf = runidentd() #todo: set ident in config file. also warn if can't open port for listening. 

#qttirc stands for Qt+Twisted IRC
#note: PyQt requires a fee for commercial use, PySide doesn't and is largely similar
#todo:
#if no realname, etc. defined for the network in the json config, default to those defined on the general level.
#if all nicks defined for a network are taken, try nicks from "nicks" outside of any network in the config file
#how do i show the server messages that are in green in mIRC
#keep scrollback below x lines
#identd
#if all alternative nicks are in use, popup a dialog asking for a nick
#input history 
#color codes input
#maybe irc commands that use server.serverconnection.* could just use server.*
#[4:15am] <mrvn> void QWidget::customContextMenuRequested ( const QPoint & pos ) [signal]
#[4:17am] <mrvn> When you get that signal you have to map the pos to global coordinates, create a QMenu and exec_() it there
#[4:17am] <mrvn> And you can use listWidget.itemAt(pos)
#find out why connection process hangs sometimes after "got ident response", or set a timeout, or something.
#make a networkusers class, so we don't have to set a nick's ident/hostmask on each channel when we discover it? and maybe other reasons, related to private messages?
#change nick in nicklist on mode update - http://www.geekshed.net/2009/10/nick-prefixes-explained/
#nickslist - don't let it keep a nick selected "item needs to be selectable. but you can style the qlistwidget with qss to make selected/normal appear same"
#use color for messages generated by the client (messages starting with *)
#move processing of commands to a separate function that is universal to server, channel and privmsg windows
#should channels be moved to server because they get erased as soon as it gets disconnected?
#make networks a dictionary
#change reconnectdelay so that it only applies to connecting to the same server again within x seconds after previous connect attempt 
#nick completion
#use fixedsys for ascii characters and excelsior for unicode. this could be a problem since excelsior sizes are different from fixedsys sizes. (e.g. 7 in fixedsys is 10 in excelsior.)
#group new channel tabs with the correct server tabs
#update user.ident, user.host, and MessageWindow for all connections having the same network name? 
#ctrl-tab and ctrl-shift-tab to switch between tabs. ctrl-f4 to part a channel
#change colors of tab labels if new messages in channels
#beep/change colors of tab labels if self.nickname mentioned in channel
#command to beep if new message in a given channel
#if privmsg from different nick, same ident@host as an open privmsg window, show in that window and do updates?
#need x buttons for windows
#dividers in tab_widget like in mIRC?
#fix "your host is, \n running version ..." <- seems there's no bug, it was a server glitch.
#once it joined channels and didn't populate the nicks lists at all.  mIRC never did that.
#start text on bottom of window like mIRC
#show connection lost in channels and messagewindows
#detect bad username error if possible - can anything be done about it?  
#select and copy doesn't seem to work right. must be a qt bug.
#ability to add a hook on an arbitrary event (including a timer event) during run-time from input.  options to do it once or every time, only in a certain channel or network, etc.
#have nicks, username, realname, ident able to be defined in config file outside of specific networks
#ability to act as a bouncer or a client for it
#fix updating of ident and host so that it doesn't look through the whole nick list of each channel each time
#make nick_lower function
#have a global user list for each network and point to those users from the channels instead of having an independent list of users for each channel?
#use User class
#have common names across qttirc.py, irc.py and scripts
#i have both irc.usersplit (used by the trivia script) and qttmwirc.splithostmask (used other places). only one should be necessary, or at least make them both work the same.
#don't change network.mynick (and the other place it changes it) if setnick returns an error from the server
#trivia plugin - when entering commands from local, the result shows up before the command
#channels are showing up twice in the switchbar for some reason
#should probably use weakref in some places with all these circular references. i think python garbage-collects circular references but collecting them takes more resources than normal collection.
#change lowercase variables to camelCase
#if we make a lot of new connections and disconnect a lot of them, do we leak connection instances? I guess we leak them in the global list "networks".
#when cycling through nicks, first use nicks that are <= maxnicklen
#there are inconsistencies in naming objects. blahblah, blah_blah, and blahBlah.
#allow to have network info's in the config file that we don't automatically connect to. maybe have a startup script and a perform script for connecting? just pipe all the lines to docommand.
#are conn and serverconnection the same thing? should I remove conn?
#i changed a lot of .lower()'s to irclower()'s that I probably shouldn't have done. Also I used conn.irclower() so it'll berak if there's no conn.
#need to have a max size for the windows' scrollbacks. i guess take a byte offset in the scrollback and then find the next line break.
#add ctrl-tab and ctrl-shift-tab to shift between tabs
#change color of tab text according to channel activity like mIRC does 
#make a better way to autojoin channels and autoconnect to networks than performonstartup.py
#support SASL
#make network-wide Users dict and have channel.users point to users in that dict
#add logging and make it able to separate logs by week, month, and trim logs to a certain size
#when saving json use https://docs.python.org/3.2/library/pprint.html
#change yaml conf file layout so that you don't need to specify a list of dictionaries because then you have to use the explicit dictionary format for everything in it
#display 'connecting to..' instead of 'connecting'
#disconnect and display 'disconected from..' when /server is called when it's already connected
#start with network name in config file as network.name in case there's no isupport network message.
#should we detect things like "Welcome to the UnderNet IRC Network" that are network specific to determine network.name? are those messages the same on all servers of a network? can we generalize a couple of cases of the the welcome message for all networks?
#rejoin open channels
#wrap a lot of things in try/excepts to be more error-tolerant
#for some reason the font isn't fixed width
#must set configname, isupportname, and welcomename to none when we connect. but then we have to set oldisupportname, etc. at the same time rather than when isupportname, etc. are updated.
#show channel topics
#recall previous inputs on up key
#/join without being connected to a server errors out
#should save a variable remembering whether any previous network was connected to in this server window, if it was then changednetworks() if all three network name variables don't match the old ones. but not necessarily, if it wasn't previously connected then switchednetworks() should do no harm.

from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtMultimedia import QSound
import sys
app = QApplication(sys.argv)
import qt5reactor
qt5reactor.install()
import yaml
import irc
from twisted.internet import protocol
from twisted.internet import reactor
#from twisted.python import log
#log.startLogging(sys.stdout)
import os, time, re, itertools, traceback, copy, os

invalidwindowsfilenamestems = set(("CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9")) #case-insensitive
invalidwindowsfilenamecharsre = re.compile('[\\\/\:\*\?\"\<\>\u0000-\u001F]')

def getlogfilepath(stem, ext):
  stem = invalidwindowsfilenamecharsre.sub(stem, "_")
  if stem.upper() in invalidwindowsfilenamestems:
    stem += "_"
  return os.path.join(qttircpath, stem + "." + invalidwindowsfilenamecharsre.sub(ext, "_") + ".log")

def runidentd():
  identf = protocol.ServerFactory()
  identf.protocol = identd
  try:
    reactor.listenTCP(113,identf)
  except:
    print("Could not run identd server.")
    #todo: show it in the gui 
  return identf

#if multiple lines inputted, detect if each line starts with "/" and run the command if it does?
class ServerInputQTextEdit(QTextEdit):
  def __init__(self, serverwindow):
    QTextEdit.__init__(self)
    self.serverwindow = serverwindow
    self.setAcceptRichText(False)
  def keyPressEvent(self, event):
    if event.key() == Qt.Key_Return:
      text = str(self.toPlainText())
      self.setPlainText("")
      if text.lstrip().startswith("/"):
        docommand("serverwindow", self.serverwindow, text)
      else:
        addline(self.serverwindow, "* Nothing performed. This is not a channel or private-message window")
        
    else:
      QTextEdit.keyPressEvent(self, event)
      
class ChannelInputQTextEdit(QTextEdit):         
  def __init__(self, channel):
    QTextEdit.__init__(self)
    self.channel = channel
    self.setAcceptRichText(False)

  def keyPressEvent(self, event):
    if event.key() == Qt.Key_Return and not (event.modifiers() and Qt.ShiftModifier):
      #text = str(self.toPlainText()) #doesn't work with unicode input
      text = unicode(self.toPlainText())
      self.setPlainText("")
      if text.lstrip().startswith("/"):
        docommand("channelwindow", self.channel.channelwindow, text)
      else:
        if self.channel.network.server.serverconnection:
          self.channel.network.server.serverconnection.msg(self.channel.name, text.encode("utf-8"))
          for msg in text.split(r"\n"): #todo: sure this should be a raw string? why did I do that? and if so, we need an escape for "\\" in case we need to do "\\n"
            addline(self.channel.channelwindow, "<%s> %s" % (self.channel.network.server.serverconnection.nickname, msg))
        else:
          addline(channel.channelwindow, self.channelwindow.channel.name + "." + self.channelwindow.network.name, "* You are not currently connected to a server") #does mIRC log responses like this that would be out of context without showing the input?
    else:
      QTextEdit.keyPressEvent(self, event)
      
def lookupnetworkconfig(name): #name = network or server name
  name = name.lower()
  print(f"name.lower(): {name.lower()}")
  print(f"{dir(config.networks)=}")
  for network_name in dir(config.networks):
    print(f"{getattr(config.networks, network_name)=}")
    network_conf = getattr(config.networks, network_name)
    if network_name.lower() == name:
      network_conf.name = network_name
      return network_conf, True
    for server, port in network_conf.servers:
      if server.lower() == name:
        network_conf.name = network_name
        return network_conf, False
  return None, True

def log(windowtype, window, text):
  if windowtype == "serverwindow":
    filestem = window.server.network.name
  elif windowtype == "channelwindow":
    filestem = window.channel.name + "." + window.server.network.name
  filepath = os.path.join(logspath, filestem + ".log")

def docommand(windowtype, window, text): #todo: test from server, channel, and privmsg
  params = text.split()   
  if params[0].lower() == "/join":
    if len(params) in (2, 3): #todo: /j for multiple channels
      if window.network.server.serverconnection:
        window.network.server.serverconnection.join(*params[1:]) 
      else:
        addline(window, filepath, "* You are not currently connected to a server")
    else:
      addline(window, "* Usage: /join <channel> [key]")
  elif params[0].lower()=="/msg":
    dest = params[1]
    #print text
    message = text.split(None, 1)[1].split(" ", 1)[1]
    window.network.server.serverconnection.msg(dest, message)
  elif params[0].lower()=="/server":
    window.serverwindow.oldconfigname = window.network.network_config.name if window.network and window.network.network_config else None
    network_config = None
    switches = params.pop(1)[1] if len(params) > 1 and params[1].startswith("-") and params[1] != "-" else "" 
    if len(params) > 3:
      addline(window, "* Usage: /server [-m] [<server> [port]]")
      return
    if "m" in switches:
      serverwindow = ServerWindow()
      serverwindows.append(serverwindow)
      mainwin.tab_widget.setCurrentWidget(serverwindow.tab_index)
      if len(params) == 1:
        network_config = copy.deepcopy(window.network.network_config)
      else:
        network_config, isbynetwork = lookupnetworkconfig(params[1])
      if len(params) == 1:
        if window.network and window.network.network_config and window.network.network_config.servername:
          network_config = window.network.network_config
        else:
          addline(window, "* No server set for the current window and none specified.")
      else:
        network_config, isbynetwork = lookupnetworkconfig(params[1])
      network = Network(None, network_config)
      #window.network = network #commented out because it seems wrong.
      #window.network.serverwindow = serverwindow      
    else:
      if len(params) == 1:
        if hasattr(window.network, "conn"):
          window.network.conn.disconnect() #does connect() automatically do this so we don't need this line? does window.network necessarily have a .conn here?
          window.network.conn.connect()
          return
        else:
          addline(window, "* No server set for the current window and none specified.")
          return
      else:
        network_config, isbynetwork = lookupnetworkconfig(params[1])
        if not network_config:
          window.network = Network()
          window.network.servername = params[1]
          if len(params) == 3:
            window.network.serverport = int(params[3])
          else:
            window.network.serverport = 6667 #should this be network.config.name and network.config.port instead? or maybe even put it in network_config? do I have name and port in network.config? I don't remember. not good to have these in three different places unnecessarily.
        else:
          if hasattr(window.serverwindow, "oldconfigname") and network_config.name != window.serverwindow.oldconfigname and window.serverwindow.oldconfigname is not None: #should we make an exception if server.oldconfigname == None?
            window.network.server.serverconnection.changednetworks(window.serverwindow.oldconfigname, network_config.name)
    temp_win = window.network.serverwindow if window.network and window.network.serverwindow else window
    mainwin.tab_widget.setTabText(temp_win.tab_index, network_config.name if network_config else params[1])
    username = network_config.username if network_config else config.username
    if username:
      username = username.encode("ascii").decode()
    password = network_config.password if network_config else None
    if password:
      password = password.encode("ascii").decode()
    realname = network_config.realname if network_config else config.realname or "qttirc"
    print(f"{network_config=}")
    network = Network(network_config=network_config)
    print(f"{dir(network_config)=}")
    nick = network_config.nicks[0] if network_config and network_config.nicks else config.nicks[0] #in the newest typescript beta this would just be
                                                                                                   #nick = network.config.nicks?.[0] ?? config.nicks[0] or something like that.
                                                                                                   #wish python had that.
                                                                                                   #https://devblogs.microsoft.com/typescript/announcing-typescript-3-7-beta/
                                                                                                   #todo: warn if nicks not specified in config file instead of erroring out
    server = ServerFactory(nickname=nick.encode("ascii").decode(), username=network_config.username.encode("ascii").decode() if network_config and network_config.username else None,
                           password=network_config.password.encode("ascii").decode() if network_config and network_config.password else None, realname=realname.encode("ascii").decode() if realname else None,
                           network=network, network_config=network_config)
    
    print(f"server.nickname: {server.nickname}, server.username: {server.username}, server.password: {server.password}, server.realname: {server.realname}, server.network: {server.network}, server.network_config: {server.network_config}")  #debug
    
    
    window.network = network
    network.server = server
    server.network = network
  
    network.serverwindow = serverwindow if "m" in switches else (window if windowtype == "serverwindow" else window.network.serverwindow)
    network.serverindex = 0
    networks.append(network)
    if window.network and window.network.conn:
      window.network.conn.disconnect()
    if network_config:
      if isbynetwork:
        servername = network_config.servers[0][0] 
        port = network_config.servers[0][1]
      else:
        servername = params[1]
        port = int(params[2]) if len(params)>2 else network_config.port if network_config.port else 6667
    else:
      servername = params[1]
      port = int(params[2]) if len(params) >= 3 else 6667
    window.network.servername = servername
    window.network.serverport = port
    window.network.conn = reactor.connectTCP(servername, port, server)
    print("got here 2") #debug
  elif params[0].lower() == "/load": #todo: should be able to send parameters to the script
    if len(params) != 2:
      addline(window, "* Usage: /load <name>")
    else:
      scripts[params[1]] = loadscript(params[1])
  else:
    addline(window, "* Command not recognized")

class MessageInputQTextEdit(QTextEdit):
  def __init__(self, messagewindow):
    QTextEdit.__init__(self)
    self.messagewindow = messagewindow
    self.setAcceptRichText(False)

  def keyPressEvent(self, event):
    if event.key() == Qt.Key_Return and not (event.modifiers() and Qt.ShiftModifier):
      text = str(self.toPlainText())
      self.setPlainText("")
      if text.lstrip().startswith("/"):
        docommand("serverwindow", self.messagewindow, text)
      else:
        if self.messagewindow.network.server.serverconnection:
          self.messagewindow.network.server.serverconnection.msg(self.nick, text)
          for msg in text.split(r"\n"):
            addline(self.messagewindow, "<%s> %s" % (self.messagewindow.network.server.serverconnection.nickname, msg))
        else:
          addline(self.messagewindow, "* You are not currently connected to a server")
    else:
      QTextEdit.keyPressEvent(self, event)

def addline(window, *args): #should probably test if fn is None, not doing that until I have a use case though.
  flag = False
  for arg in args:
    #window.openlogfile.write(arg.encode("utf-8"))
    if flag:
      window.textwindow.insertHtml(arg)
    else:
      window.textwindow.insertPlainText(arg)
      window.openlogfile.write(arg.encode("utf-8").decode())
    flag = not flag
  window.openlogfile.write("\n")
  window.textwindow.insertHtml("<br>")
  window.textwindow.moveCursor(QTextCursor.End) #not sure this is necessary, it was in an example for doing this for some reason. (something about Qt adding extra newlines)
  scrollbar = window.textwindow.verticalScrollBar()
  scrollbar.setValue(scrollbar.maximum())

def addlinecolored(window, *args): #todo: remove the redundancy between addline for server windows and addline for channel windows and addline for message windows
  flag = False
  for arg in args:
    if flag:
      window.textwindow.insertHtml(arg)
    else:
      colorify(window.textwindow, arg)
      window.openlogfile.write(arg) #should make an option to leave colors out of log files.
    flag = not flag
  window.openlogfile.write("\n")
  window.textwindow.insertHtml("<br>")
  window.textwindow.moveCursor(QTextCursor.End) #not sure this is necessary, it was in an example for doing this for some reason.
  scrollbar = window.textwindow.verticalScrollBar()
  scrollbar.setValue(scrollbar.maximum())

class MessageWindow(QWidget):
  def __init__(self, network, nick):
    QWidget.__init__(self)
    self.network = network
    self.nick = nick
    mainwin.tab_widget.addTab(self, nick)
    self.textwindow = QTextEdit(self)
    self.textwindow.setReadOnly(True)
    self.textwindow.setFont(font)
    #self.textwindow.setStyleSheet(f'''font: {config.font_size or 16}pt "{config.font or 'Fixedsys'}";''')
    #self.textwindow.setStyleSheet("* {position: absolute; bottom: 0}") #doesn't work
    self.layout = QVBoxLayout(self)
    self.layout.setContentsMargins(0, 0, 0, 0)
    self.layout.addWidget(self.textwindow)
    self.editwindow = MessageInputQTextEdit(self) 
    self.editwindow.setFont(font)
    #self.editwindow.setStyleSheet(f'''font: {config.font_size or 16}pt "{config.font or 'Fixedsys'}";''')
    self.layout.addWidget(self.editwindow)
    #sizepolicy = QSizePolicy()
    #sizepolicy.setVerticalPolicy()
    #self.editwindow.setSizePolicy(sizepolicy)
    self.editwindow.setFixedHeight(40)
    self.editwindow.setFocus()
    self.logfilepath = getlogfilepath(nick, network.name)
    self.openlogfile = open(self.logfilepath, "a")
  def __del__(self):
    self.openlogfile.close()
    
#class ChannelNicks(QTextEdit):
#  def __init__(self):
#    QTextEdit.__init__(self)
    
class User:
  def __init__(nick, network, ident=None, host=None, realname=None, channels=None, querywindow=None):
    self.nick = nick
    self.network = network
    self.ident = ident
    self.host = host
    self.realname = realname or "qttirc"
    self.channels = channels
    self.message = messagewindow

class ServerWindow(QWidget):
  def __init__(self, network=None):
    QWidget.__init__(self)
    self.network = network
    self.subwindows = dict()
    self.tab_index = mainwin.tab_widget.addTab(self, network.config.name if network else "Server window")
    self.textwindow = QTextEdit(self)
    self.textwindow.setAlignment(Qt.AlignLeft | Qt.AlignBottom) #doesn't work
    self.textwindow.setReadOnly(True)
    self.textwindow.setFont(font)
    self.textwindow.setStyleSheet("* {position: absolute; bottom: 0}") #doesn't work
    self.layout = QVBoxLayout(self)
    self.layout.setContentsMargins(0, 0, 0, 0)
    self.layout.addWidget(self.textwindow)
    self.editwindow = ServerInputQTextEdit(self) 
    self.editwindow.setFont(font)
    self.layout.addWidget(self.editwindow)
    #sizepolicy = QSizePolicy()
    #sizepolicy.setVerticalPolicy()
    #self.editwindow.setSizePolicy(sizepolicy)
    self.editwindow.setFixedHeight(40)
    self.editwindow.setFocus()
    self.serverwindow = self
    self.logfilepath = getlogfilepath("status", network.name if network else "")
    self.openlogfile = open(self.logfilepath, "a")
  def __del__(self):
    self.openlogfile.close()

def newserverwindow():
  serverwindow = ServerWindow()
  serverwindows.append(serverwindow)
      
class Channel:
  def __init__(self, channelname, network, channelwindow=None):
    self.name = channelname
    self.users = {}
    self.network = network
    self.network.channels[irc.irclower(channelname)] = self
    self.channelwindow = channelwindow
  #def adduser(nick, prefix=None, hostmask=None):
  #  self.users[nick] = ChannelUser(nick, prefix, hostmask)
  #  self.channelwindow.nickslist.setHtml("<br>".join(sorted(self.users.keys()))) #fortunately nicks can't have < or > in them. if i weren't lazy i would replace them anyway with &lt or whatever (assuming pyqt even supports that)
  def adduser(self, nick):
    self.users.add(nick)
    self.updateuserlist()
  def removeuser(self, nick):
    self.users.remove(nick)
    self.updateuserlist()
  def updateuserlist(self):
    self.channelwindow.nicks.setText('\n'.join(sorted(self.nicks)))
    #todo: nick formatting options, sorting by status options, right-clickable, hoverable, size according to longest nick option (can we even do this?)
  def post(self, message):
    self.network.server.serverconnection.say(self.name, message) #todo: length check
    addlinecolored(self.channelwindow, "<%s> %s" % (self.network.mynick, message))
  def rejoined(self):
    pass #todo
    
class User:
  def __init__(self, nick, prefix=None, ident=None, host=None, realname=None, server=None, loggedinas=None, onchannels=None):
    self.prefix = prefix
    self.host = host
    self.nick = nick
    self.ident = ident
    self.realname = None
    self.servername = None
    self.loggedinas = None
    self.onchannels = None
      
def nickslistcontextmenu(position):
  

class ChannelWindow(QWidget):
  def __init__(self, channel, network):
    QWidget.__init__(self)
    self.tab_index = mainwin.tab_widget.addTab(self, channel.name)
    mainwin.tab_widget.setCurrentIndex(self.tab_index)
    self.channel = channel
    self.splitter = QSplitter(self)
    self.nickslist = QListWidget(self)
    self.nickslist.setSortingEnabled(True)
    self.nickslist.setFont(font)
    #self.nickslist.setReadOnly(True) #in case we change this back to a QTextEdit
    self.textwindow = QTextEdit(self)
    self.textwindow.setReadOnly(True)
    self.textwindow.setFont(font)
    self.textwindow.setStyleSheet("* {position: absolute; bottom: 0}")
    self.splitter.addWidget(self.textwindow)
    self.splitter.addWidget(self.nickslist)
    self.network = network
    self.vlayout = QVBoxLayout(self)
    self.vlayout.setContentsMargins(0, 0, 0, 0)
    self.vlayout.addWidget(self.splitter)
    self.editwindow = ChannelInputQTextEdit(channel)
    self.editwindow.setFont(font)
    self.vlayout.addWidget(self.editwindow)
    nickswidth = self.nickslist.width()
    textwidth = self.textwindow.width()
    self.editwindow.setFixedHeight(40)
    self.editwindow.setFocus()
    
    print(f"{self.channel.name =}")
    print(f"{network.name =}")
    
    name = getattr(network.serverwindow, "isupportname", None) or getattr(netwrk.serverwindow, "configname", None) or getattr(netwrk.serverwindow, "welcomename", None) or "unknown_network"
    
    self.logfilepath = getlogfilepath(self.channel.name, network.serverwindow.isupportname or name)
    
  
    self.openlogfile = open(self.logfilepath, "a")
  def __del__(self):
    self.openlogfile.close()
  
class NickItem(QListWidgetItem):
  def __init__(self, nick, user):
    QListWidgetItem.__init__(self, nick)
    self.user = user
  def __lt__(self, other):
    return self.text().lower() < other.text().lower() #todo: is "@" < "+"? cuz we want ops on top. | do we want irclower here?
  
class Network(object):
  def __init__(self, server=None, network_config=None, mynick=None, serverwindow=None):
    self.conn = None
    self.server = server
    self.isupport = {}
    print("network class")
    print(f"self.network_config=")
    self.network_config = network_config
    self.channels = {}
    self.mynick = mynick
    self.name = None
    self.messagewindows = {} #should this be another class whose objects have messagewindow as an attribute? and if so, what would i call the class?
    self.serverwindow = serverwindow
    self.nicks = [nick+suffix for suffix in ("", "_", "__", "___", "`", "``", "```") for nick in ((getattr(network_config, "nicks", []) or []) + (config.nicks or [])) or ["qttirc"]]
        
def splithostmask(hostmask):
  if "!" in hostmask:
    nick, rest = hostmask.split("!", 1)
  else:
    nick, rest = hostmask, ""
  if "@" in rest:
    ident, host = rest.split("@", 1)
  else:
    ident, host = "", ""
  return nick, ident, host

colorre = re.compile("(?:\x03(?:\\d\\d?(?:,\\d\\d?)?)?)|\x02|\x1f|\x16|\x1d")
#irccolors = ["#FFFFFF",    "#000000", "#00007F",   "#009300",    "#FF0000",   "#7F0000",  "#9C009C",      "#FC7F00",
#              "#FFFF00",    "#00FC00",   "#009393",   "#00FFFF",     "#0000FC", "#FF00FF",     "#7F7F7F",      "#D2D2D2"]
irccolors = ((255,255,255), (0, 0, 0), (0, 0, 127), (0, 147, 00), (255, 0, 0), (127, 0, 0), (156, 0, 156), (252, 127, 0),
             (255,255,0), (0, 252, 0), (0, 147, 147), (0, 255, 255), (0, 0, 252), (255, 0, 255), (127, 127, 127), (210, 210, 210))
#irccolors = ["White", "Black", "Navy Blue", "Green", "Red", "Brown", "Purple", "Olive", "Yellow", "Lime Green", "Teal", "Aqua Light", "Royal Blue", "Hot Pink", "Dark Gray", "Light Gray"]
# actual names of colors from http://www.ircbeginner.com/ircinfo/colors.html - untested

def colorify(widget, msg): #should behave just like mIRC.
  matches = re.findall(colorre, msg)
  texts = re.split(colorre, msg)
  bold = False
  underline = False
  italics = False
  reversed = False
  origcolorf = widget.textColor()
  #origcolorb = widget.textBackgroundColor() #doesn't fucking work
  origcolorb = QColor(255, 255, 255) #todo: get this value from configuration, if we add a configuration option for this.  also, report a bug re textBackgroundColor. i think qt4 support is discontinuing december 2015.
  curcolorf = origcolorf
  curcolorb = origcolorb
  for (text, code) in itertools.izip_longest(texts, matches): 
    widget.insertPlainText(text)
    if code:
      if code == "\x02":
        bold = not bold
        widget.setFontWeight(QFont.Bold if bold else QFont.Normal) 
      elif code == "\x1f":
        underline = not underline
        widget.setFontUnderline(underline)
      elif code == "\x1d":
        italics = not italics
        widget.setFontItalic(italics)
      elif code == "\x16":
        reversed = not reversed
        if reversed:
          widget.setTextColor(origcolorb)
          widget.setTextBackgroundColor(origcolorf)
        else:
          widget.setTextColor(curcolorf)
          widget.setTextBackgroundColor(curcolorb)
      elif code[0] == "\x03":
        if code == "\x03":
          curcolorf = origcolorf
          curcolorb = origcolorb
          if not reversed:
            widget.setTextColor(curcolorf)
            widget.setTextBackgroundColor(curcolorb)
        else:
          codes = code[1:].split(",")
          curcolorf = QColor(*irccolors[int(codes[0])])
          widget.setTextColor(curcolorf)
          if len(codes) == 2:
            curcolorb = QColor(*irccolors[int(codes[1])])
            widget.setTextBackgroundColor(curcolorb)
  widget.setTextColor(origcolorf)
  widget.setTextBackgroundColor(origcolorb)

     
def yaml_to_namespaces(b):
  if type(b) == list:
    o = []
    for e in b:
      o.append(yaml_to_namespaces(e))
  elif type(b) == dict:
    class O(object):
      def __init__(self, d):
        self.d = d
      def __getattr__(self, attr):
        if attr in self.d:
          return yaml_to_namespaces(self.d[attr])
        else:
          return None
      def __dir__(self):
        return self.d.keys()
    o = O(b)
  #elif type(b) in (unicode, int, float):
  else:
    o = b.encode("ascii").decode() if type(b) == bytes else b
  return o

class Script: 
  def __init__(self, module, script):
    self.module = module
    self.script = script

def loadscript(scriptfn):
  scriptpath = os.path.join(scriptspath, scriptfn)
  if scriptfn.lower().endswith(".py"):
    scriptname = scriptfn[:-3]
  elif os.path.isdir(scriptpath):
    if os.path.exists(os.path.join(scriptpath, "__init__.py")):
      scriptname = scriptfn
  try:
    __import__("scripts."+scriptname)
    scriptmodule = sys.modules["scripts."+scriptname]
    script = Script(scriptmodule, scriptmodule.Script(networks, serverwindows, docommand))
  except Exception as inst:
    raise #debug
    print('Could not load script "%s" from "%s" because of error: %s' % (scriptname, scriptpath, inst.message))
    #todo: gui
  return script 

# def loadscripts():
#   scripts = {}
#   for scriptfn in os.listdir(os.path.join(mypath, "scripts")):
#     if not scriptfn.startswith("_"):
#       scriptpath = os.path.join(scriptspath, scriptfn)
#       if scriptfn.lower().endswith(".py"):
#         scriptname = scriptfn[:-3]
#       elif os.path.isdir(scriptpath):
#         if os.path.exists(os.path.join(scriptpath, "__init__.py")):
#           scriptname = scriptfn
#       try:
#         __import__("scripts."+scriptname)
#         script = sys.modules["scripts."+scriptname]
#         scripts[scriptname] = Script(script, script.Script(networks))
#         
#         
#       except Exception, inst:
#         raise #debug
#         print 'Could not load script "%s" from "%s" because of error: %s' % (scriptname, scriptpath, inst.message)
#         #todo: gui
#   return scripts

def makefunc(name, obj):#one way to do closure in Python
  def f(self, *args, **kwargs): 
    for script in scripts.itervalues():
      obj2 = getattr(script.script, name, None)
      try:
        if obj2 and obj2(self, *args, **kwargs):
          break
      except:
        traceback.print_exc()
    else:
      return obj(self, *args, **kwargs)
  return f
  
def clickable(widget):
  class Filter(QObject):
    clicked = pyqtSignal()
    def eventFilter(self, obj, event):
      if obj == widget:
        if event.type() == QEvent.MouseButtonRelease:
          if obj.rect().contains(event.pos()):
            self.clicked.emit()
            # The developer can opt for .emit(obj) to get the object within the slot.
            return True
              
      return False
      
  filter = Filter(widget)
  widget.installEventFilter(filter)
  return filter.clicked

class MainWindow(QMainWindow):
  
  def __init__(self):
    QMainWindow.__init__(self)
    self.setWindowTitle("qttmwirc")
    self.mainmenu = self.menuBar()
    self.closetab = QLabel()
    self.restoretab = QLabel()
    self.minimizetab = QLabel()
    self.minimizetab.setPixmap(QPixmap("minus-box_318-27566.jpg").scaledToWidth(20))
    self.restoretab.setPixmap(QPixmap("download.png").scaledToWidth(20))
    self.closetab.setPixmap(QPixmap("cross-remove-sign_318-75006.jpg").scaledToWidth(20))
    self.hlayout = QHBoxLayout()
    self.hlayout.addWidget(self.minimizetab)
    self.hlayout.addWidget(self.restoretab)
    self.hlayout.addWidget(self.closetab)
    clickable(self.minimizetab).connect(self.doMinimizeTab)
    self.minimizerestoreclose = QWidget()
    self.minimizerestoreclose.setLayout(self.hlayout)
    self.mainmenu.setCornerWidget(self.minimizerestoreclose, Qt.TopRightCorner)
    self.minimizerestoreclose.show() 
    #self.mainmenu.setCornerWidget(self.test2, Qt.TopRightCorner) #debug
    
    self.extractAction = QAction("&Exit", self)
    self.extractAction.triggered.connect(self.closeEvent)
    self.fileMenu = self.mainmenu.addMenu('&File')
    self.mnunew = self.fileMenu.addMenu("&New")
    self.fileMenu.addAction(self.extractAction)
    self.newclientaction = QAction("&Server window", self)
    self.newclientaction.triggered.connect(newserverwindow)
    self.mnunew.addAction(self.newclientaction)
    self.tab_widget = QTabWidget()
    self.vbox = QVBoxLayout() 
    self.vbox.addWidget(self.tab_widget)
    self.vbox.setContentsMargins(0, 0, 0, 0)
    self.setCentralWidget(self.tab_widget)
    self.showMaximized()

  
  #def close_application(self):
  #  reactor.stop()
  #  sys.exit()
    
  def closeEvent(self, event):
    QCoreApplication.instance().quit()
    
  def doMinimizeTab(self):
    #print "test" #debug
    pass
  
  
serverwindows = [] 
# 
# class MainWindow(QMainWindow):
# def __init__(self):
#   super(MainWindow, self).__init__()
#   self.initUI()
#   
# def initUI(self):
#   self.workspace = QMdiArea()
#   self.showMaximized()
# 
# def closeEvent(self, event):
#     QCoreApplication.instance().quit()

class ServerConnection(irc.IRCClient):
  
  def __init__(self):
    self.signedon = False
    self.nickindex = 0
    
  def signedOn(self):
    #print "signed on"
    addline(self.server.network.serverwindow, "* You are now signed on.")
    self.signedon = True
    mainwin.tab_widget.setTabText(mainwin.tab_widget.indexOf(self.server.network.serverwindow), "%s - %s" % (self.server.network.name, self.nickname)) #might be better to store the index
    for channel in self.server.network_config.channels:
      self.join(channel) #todo: doesn't work for some reason
     
  def IRCcommand(self, command, prefix, params): #relies on a change to irc.py
    #print [command, prefix, params]
    #addline(self.server.network.serverwindow, repr([command, prefix, params])) #debug
    #if command not in ("PING", "PONG", "MODE", "RPL_NAMREPLY", "RPL_ENDOFNAMES", "JOIN", "RPL_TOPIC", "333"): #todo: handle notice and add it to this list. and of course, only show params
    #print(' '.join(params[1:])) #debug
    
    addline(self.server.network.serverwindow, ' '.join(params[1:]))
      
  def nickChanged(self, newnick):
    self.nickname = newnick.decode()
    addline(self.server.network.serverwindow, "* Your nick has been changed to " + newnick)
    mainwin.tab_widget.setTabText(mainwin.tab_widget.indexOf(self.server.network.serverwindow), "%s - %s" % (self.server.network.network_config["name"], self.nickname)) #might be better to store the index
    for channel in self.server.network.channels.values():
      addline(channel.channelwindow, "* Your nick has been changed to " + newnick)
    for messagewindow in self.server.network.messagewindows:
      addline(messagewindow, "* Your nick has been changed to " + newnick)
      
  def irc_RPL_WELCOME(self, prefix, params): #actually we should be doing this in irc_RPL_ISUPPORT (NETWORK=). do both? do all irc servers send ISUPPORT NETWORK=?
    if params[1].startswith("Welcome to the "):
      welcomename = params[1].split()[3] #do network names ever have more than one word in them? i'm only capturing one word because i saw both "irc network" and "internet chat relay network" after this word
      oldwelcomename = getattr(self.server.network.serverwindow, "welcomename", None) #should networkname go under network, server or serverconnection? 
      self.server.network.serverwindow.welcomename = welcomename 
      if oldwelcomename and (welcomename.lower() != oldwelcomename.lower()): #calling .lower here is the Right Thing to do, right? 
        self.changednetworks(oldwelcomename, welcomename)
       
  def irc_RPL_ISUPPORT(self, prefix, params):
    for param in params[1:]:
      keyvalue = param.split("=",1)
      if len(keyvalue) == 2:
        self.server.network.isupport[keyvalue[0]]=keyvalue[1]
      else:
        self.server.network.isupport[keyvalue[0]]=None
      if keyvalue[0] == "NETWORK":
        networkname = keyvalue[1] #ISUPPORT NETWORK without an =somevalue will cause an exception but who cares. exceptions are eaten, and why would a server do that?
        oldnetworkname = getattr(self.server.network.serverwindow, "isupportname", None) 
        self.server.network.serverwindow.isupportname=networkname
        
        print(f"networkname = ") 
        
        mainwin.tab_widget.setTabText(self.server.network.serverwindow.tab_index, networkname)
        if oldnetworkname and (networkname.lower() != oldnetworkname.lower()): #calling .lower here is the Right Thing to do, right? 
          self.changednetworks(oldnetworkname, networkname)
  #       #todo: we may also want to do something if networkname.lower() != self.server.network.config["name"].lower()

  def changednetworks(self, oldnetworkname, newnetworkname): #should probably rename this to networkchanged to make it more consistent
    self.server.network.serverwindow.subwindows = dict()
    for channel in self.network.channels.iterValues():
      channel.channelwindow.deleteLater()
    self.network.channels = {}
    for messagewindow in self.network.messagewindows.iterValues():
      messagewindow.deleteLater()
    self.network.messagewindows = {}
    self.serverwindow.openlogfile.close()
    self.serverwindow.logfilepath = getlogfilepath("status", newnetworkname)
    self.serverwindow.openlogfile = open(self.logfilepath, "a")
    
  def irc_RPL_NAMREPLY(self, prefix, params):
    channelname_lower = irc.irclower(params[2])
    for nick in params[3].split():
      nmo = re.match(r"([^a-zA-Z_[\]{}^`|]*).*", nick) #numbers and - can't be first character of a nick
      np = nick[:nmo.end(1)]
      nwp = nick[nmo.end(1):]
      nwp_lower = nwp.lower() #what is nwp. should I be using irclower() here?
      user = User(nwp, prefix=np)
      channel = self.server.network.channels[channelname_lower]
      channel.users[nwp_lower] = user
      #self.server.channels[channelname_lower].channelwindow.nickslist.insertHtml(nick + "<br>")
      item = NickItem(nick, user)
      print("irc_rpl_namreply") 
      print(f"{self.server.network.channels[channelname_lower].channelwindow=}")
      channel.channelwindow.nickslist.addItem(item)
      channel.users[nwp_lower].item = item
      
  def irc_ERR_NICKNAMEINUSE(self, prefix, params):
    if not self.signedon: #should test if this is correct.
      #oldnick = self.server.network.network_config.nicks[self.nickindex]
      oldnick = self.nickname
      if self.server.network.network_config:
        self.nickindex = self.nickindex+1
        if self.nickindex < len(self.server.network.nicks):
          newnick = self.server.network.nicks[self.nickindex]
          self.nickindex += 1
      addline(self.server.network.serverwindow, '* Nick "%s" is already in use. Changing nick to "%s"' % (oldnick, newnick))
      self.setNick(newnick)
      self.server.network.mynick = newnick
      self.nickname = newnick #do i have to do this? (the answer is yes. not sure why. maybe the server doesn't send a changed nick command when you're not signed on yet so irc.py doesn't update nickname. or maybe something needs to be .decode()d.)
    else:
      print(f"{params=}")
      addline(self.server.network.serverwindow, ' * Nick "%s" is already in use' % params[2])#todo: find out where %s is in the params
      
  def irc_ERR_ERRONEUSNICKNAME(self, prefix, params):
    if not self.signedon: #should test if this is correct.
      oldnick = self.nickname
      if self.server.network.network_config:
        self.nickindex = self.nickindex+1
        if self.nickindex < len(self.server.network.nicks):
          newnick = self.server.network.nicks[self.nickindex]
          self.nickindex += 1
      print(f"{newnick=}")
      addline(self.server.network.serverwindow, '* Nick "%s" is erroneous. Changing nick to "%s"' % (oldnick, newnick)) #todo: use oldnick from params instead of config.
      self.setNick(newnick)
      self.nickname = newnick.decode() #do i have to do this?
    else:
      print(f"{params=}")
      addline(self.server.network.serverwindow, ' * Nick "%s" is erroneous' % params[2])#todo: find out where %s is in the params
      
  def kickedFrom(self, channelname, kicker, message):
    channels = self.server.network.channels
    channel = channels[irc.irclower(channelname)]
    nick, ident, host = splithostname(kicker)
    addline(channel.channelwindow, "* You were kicked from %s by %s (%s@%s) for reason: %s" % (channelname, nick, ident, host, message))
    for user in [user for user in channel.users.values() for channel in channels.values() if user.nick==nick]:
      if ident: user.ident = ident
      if host: user.host = host
    nickslist = channel.nickslist
    for (nick_lower, user) in channel.users.iteritems():
      nickslist.takeItem(nickslist.row(user.item))
      del channel.users[nick_lower]
 
  def userKicked(self, kickednick, channelname, kicker, message):
    kickernick, kickerident, kickerhost = splithostmask(kicker)
    kickednick_lower = irc.irclower(kickednick)
    for user in [user for user in channel.users.values() for channel in channels.values() if user.nick==kickernick]:
      if kickerident: user.ident = kickerident
      if kickerhost: user.host = kickerhost
    channel = self.server.network.channels[irc.irclower(channelname)]
    addline(channel.channelwindow, "* %s was kicked from %s by %s (%s@%s) for reason: %s" % (kickednick, channelname, kickernick, kickerident, kickerhost, message))
    nickslist = channel.channelwindow.nickslist
    nickslist.takeItem(nickslist.row(channel.users[kickednick_lower].item))
    del channel.users[kickednick_lower]
 
  def userRenamed(self, oldnick, newnick):
    oldnick_lower = irc.irclower(oldnick)
    for channel in self.server.network.channels.values():
      if oldnick_lower() in channel.users:
        user = channel.users[oldnick_lower]
        channel.users[irc.irclower(newnick)] = user
        del channel.users[oldnick_lower]
        user.nick = newnick
        user.item.setText(user.prefix + newnick)
        addline(channel, "* %s is now %s" % (oldnick, newnick))
    if oldnick_lower in self.server.network.messagewindows:
      messagewindows = self.server.network.messagewindows
      messagewindow = messagewindows[oldnick_lower]
      messagewindows[irc.irclower(newnick)] = messagewindow
      del messagewindows[oldnick_lower]
      mainwin.tab_widget.setTabText(mainwin.tab_widget.indexOf(self), newnick) #might be better to store the index
      addline(messagewindow, "* %s is now %s" % (oldnick, newnick))

  def privmsg(self, fromhostmask, msg):
    nick, ident, host = splithostmask(fromhostmask)
    msg = QString.fromUtf8(msg)
    fromnick_lower = irc.irclower(nick)
    if fromnick_lower not in self.server.network.messagewindows:
      self.server.network.messagewindows[fromnick_lower] = MessageWindow(self.server.network, nick)
      ding.play()
    messagewindow = self.server.network.messagewindows[fromnick_lower]
    addlinecolored(messagewindow, "<%s> %s" % (nick, msg))
          
  def chanmsg(self, fromhostmask, target, msg):
    target_lower = irc.irclower(target)
    nick, ident, host = splithostmask(fromhostmask)
    msg = QString.fromUtf8(msg)
    if target_lower in self.server.network.channels:
      channel = self.server.network.channels[target_lower]
      nick, ident, host = splithostmask(fromhostmask)
      #addline(channel.channelwindow, "<%s> %s" % (nick, msg))
      colorify(channel.channelwindow.textwindow, "<%s> %s" % (nick, msg))
      addline(channel.channelwindow, "") 
      if irc.irclower(nick) in channel.users: #i think ircops can sometimes hang out invisible and speak
        user = channel.users[irc.irclower(nick)]
        user.nick = nick
        if ident: user.ident = ident
        if host: user.host = host
    
  def userJoined(self, hostmask, channelname): #relies on a change to irc.py
    nick, ident, host = splithostmask(hostmask)
    nick_lower = irc.irclower(nick)
    channels = self.server.network.channels
    channel = channels[irc.irclower(channelname)]
    addline(channel.channelwindow, "* %s (%s@%s) has joined %s" % (nick, ident, host, channel.name))
    user = network.users.get(nick_lower, User(nick))
    network.users[nick_lower] = user
    #channel.users[self.conn.nick.lower()] = user #wtf why am i setting it to myself, fixing this
    item = NickItem(nick, user)
    user.item = item
    for user in [user for user in channel.users.values() for channel in channels.values() if user.nick==nick]:
      if ident: user.ident = ident
      if host: user.host = host
 
  def userLeft(self, hostmask, channelname):
    nick, ident, host = splithostmask(hostmask)
    nick_lower = irc.irclower(nick)
    channel = self.server.network.channels[channelname.lower()]
    addline(channel.channelwindow, "* %s (%s@%s) has left %s" % (nick, ident, host, channel.name))
    nickslist = channel.channelwindow.nickslist
    nickslist.takeItem(nickslist.row(channel.users[nick_lower].item))
    del channel.users[nick_lower]
 
  def userQuit(self, hostmask, quitmsg):
    nick, ident, host = splithostmask(hostmask)
    nick_lower = irc.irclower(nick)
    for channel in self.server.network.channels.values():
      if nick_lower in channel.users.keys(): #not sure it's safe to modify the dict while iterating over it but using .keys() should be fine
        addline(channel.channelwindow, "* %s (%s@%s) has quit IRC: %s" % (nick, ident, host, quitmsg))
        nickslist = channel.channelwindow.nickslist
        nickslist.takeItem(nickslist.row(channel.users[nick_lower].item))
        del channel.users[nick_lower]
    messagewindow = self.server.network.messagewindows.get(nick_lower)
    if messagewindow:
      addline(messagewindow, "* %s (%s@%s) has quit IRC: %s" % (nick, ident, host, quitmsg))
    
  def joined(self, channelname):
    print("joined "+channelname)
    channelname_lower = irc.irclower(channelname)
    channel = Channel(channelname, self.server.network)
    if channelname_lower in self.server.network.serverwindow.subwindows:
      channel.channelwindow = self.server.network.serverwindow.subwindows[channelname_lower]
    else:
      channelwindow = ChannelWindow(channel, self.server.network)
      channel.channelwindow = channelwindow
      channel.channelwindow.serverwindow = self.server.network.serverwindow
    addline(channel.channelwindow, "* joined "+ channelname)
    self.server.network.channels[channelname_lower] = channel
    print("------------joined------------")
    print(f"{self.server.network.channels[channelname_lower].channelwindow=}")
    self.server.network.serverwindow.subwindows[channelname_lower] = channelwindow
    app.processEvents()
    sizes = channelwindow.splitter.sizes()
    channelwindow.splitter.setSizes([sum(sizes)-150, 150])
  
  def modeChanged(self, hostmask, channelname, added, modes, params): #problem: displaying mode changes the way i do may mislead users about how one *sets* modes.
    channel = self.server.network.channels.get(irc.irclower(channelname))
    nick, ident, host = splithostmask(hostmask)
    if channel is not None:
      nmd = {"q": "~", "a": "&", "o": "@", "h": "%", "v": "+"} #is this the way a *real* irc client updates nicks in the nick list upon mode change?
      mctexts = []
      if added:
        for mc in zip(modes, params):
          if mc[1]:
            mctexts.append("+%s %s" % mc)
            nickprefix = nmd.get(mc[0])
            if nickprefix:
              user = channel.users.get(irc.irclower(mc[1]))
              if user: #something is wrong if user is None, but i'm not just asssuming it won't be because then if it is the mode changes won't be shown in channel, and also it won't process the rest of the mode changes.
                user.prefix = nickprefix
                user.item.setText(nickprefix + mc[1])
          else:
            mctexts.append("+" + mc[0])
      else: #removed
        for mc in zip(modes, params):
          if mc[1]:
            mctexts.append("-%s %s" % mc)
            nickprefix = nmd.get(mc[0])
            if nickprefix:
              user = channel.users.get(irc.irclower(mc[1]))
              if user: #something is wrong if user is None, but i'm not just asssuming it won't be because then if it is the mode changes won't be shown in channel, and also it won't process the rest of the mode changes.
                if user.prefix == nickprefix:
                  user.prefix = ""
                  user.item.setText(mc[1])
          else:
            mctexts.append("-" + mc[0])
      addline(channel.channelwindow, "* %s sets mode(s): %s" % (nick, ", ".join(mctexts)))
      user = channel.users[irc.irclower(nick)]
      if ident: user.ident = ident
      if host: user.host = host
    else:
      if channelname == self.nickname:
        mctexts = []
        if added:
          for mc in zip(modes, params):
            if mc[1]:
              mctexts.append("+%s %s" % mc)
            else:
              mctexts.append("+" + mc[0])
        else:
          for mc in zip(modes, params):
            if mc[1]:
              mctexts.append("-%s %s" % mc)
            else:
              mctexts.append("-" + mc[0])
        addline(self.server.network.serverwindow, "* %s sets mode(s): %s" % (nick, ", ".join(mctexts)))
      else:
        print("error: mode changes but target not recognized as a channel i'm in or as my own nick.  channelname: \"%s\"; self.nickname: \"%s\"" % (channelname, self.nickname))

class ServerFactory(protocol.ReconnectingClientFactory):
  def __init__(self, nickname="qttirc", password=None, username="qttirc", realname=None, network=None, network_config=None):
    self.network = network
    print("ServerFactory")
    print(f"self.network_config=")
    self.network_config = network_config
    self.network.mynick = nickname
    self.nickname = nickname
    self.username = username
    self.password = password
    self.realname = realname or "qttirc"
    protocol.ReconnectingClientFactory.initialDelay = 10 #should i leave this at 1?
    protocol.ReconnectingClientFactory.maxDelay = 10 #no idea what value this should be. 3.5 wasn't slow enough, i was being throttled.
    
  def startedConnecting(self, connector):
    print("did this 5") #debug
    pass
  
  def buildProtocol(self, addr):
    p = ServerConnection()
    self.serverconnection = p
    p.server = self
    p.nickname = self.nickname
    p.username = self.username
    self.resetDelay()
    return p

  def clientConnectionLost(self, connector, reason):
    """If we get disconnected, reconnect to server."""
    self.serverconnection = None
    addline(self.network.serverwindow, f"* Disconnected. Reconnecting...") #provide some way to view reason? they tend to be multiple lines..
    #reactor.callLater(config.reconnectdelay, connector.connect)
    for channel in self.network.channels.values():
      channel.channelwindow.nickslist.clear()
    #self.network.channels = {} #todo: maybe we shouldn't do this because the windows are still open. just empty the users.
    protocol.ReconnectingClientFactory.clientConnectionLost(self, connector, reason)

    #connector.connect()
    
  def clientConnectionFailed(self, connector, reason):
    self.serverconnection = None
    if self.network_config:
      oldaddr, oldport = self.network_config.servers[self.network.serverindex] if self.network_config else (None, None) #todo: if none, none then string formatting will break further down
      self.network.serverindex = (self.network.serverindex+1) % len(self.network_config.servers) #todo: make it actually use these values
      addr, port = self.network_config.servers[self.network.serverindex]

      print( "oldaddr:", oldaddr)
      print ("oldport:", oldport)
      print ("addr:", addr)
      print( "port:", port)

      addline(self.network.serverwindow, "* Connection to (%s, %d) failed. Connecting to (%s, %d)..." % (oldaddr, oldport, addr, port)) #todo: add reason for fail

      
      print("did this 4") #debug
      
    #reactor.callLater(config.reconnectdelay, reactor.connectTCP, addr.encode("ascii"), port, self)
      reactor.connectTCP(addr, port, self) #is this feasible? i don't know a better way to do this. connector.connect() apparently doesn't take server/port as arguments.
    
    else:
      
      print("did this 3") #debug
      print(f"{dir(self)=}")
      addline(self.network.serverwindow, f"* Connection to ({self.network.servername}, {self.network.serverport}) failed. Reconnecting...") #todo: add reason for fail
        
    ##why did this break #todo: fix
    #for script in activescripts:
    #  
    #  obj = getattr(script.script, name, None)
    #  try:
    #    if obj and obj(self, connector.factory, reason): #connector.factory works?
    #      break
    #  except:
    #    traceback.print_exc()
          
    protocol.ReconnectingClientFactory.clientConnectionFailed(self, connector, reason)

class identd(protocol.Protocol):
  def dataReceived(self, data):
    self.transport.write(data.strip() + " : USERID : UNIX : " + config.identid + "\r\n" )
    #todo: configure id per network


if __name__ == '__main__':

  def stop():
    print("Stop")
    if reactor.running:
      reactor.stop()
  
  
  
  #window = MainWindow()
  #window.show()
  app.lastWindowClosed.connect(stop)
 # reactor.run()
  
  #from twistedclient import SocketClientFactory
  #from twisted.words.protocols import irc
  
  qttircpath = os.path.dirname(os.path.abspath(__file__))
  scriptspath = os.path.join(qttircpath, "scripts")
  logspath = os.path.join(qttircpath, "logs") #maybe make this configurable in the future


  
#  path = os.path.join(os.path.split(sys.executable)[0], "Lib","site-packages","pywin32_system32")
#  os.environ["PATH"] = os.environ["PATH"] + ";" + path

  #app.lastWindowClosed.connect(app.quit)
  
  mainwin = MainWindow()
  #mainwin.mnunewclient.connect(mainwin.mnunewclient, SIGNAL('triggered()'), newclient)
#  mainwin.showMaximized()
  
 
  
  ding = QSound(r"sounds\01_ECHOBEL3.wav") #todo: find out how to get directory of this running python file and os.join that with sounds\whatever
  
  
    
  #mainwindow = MainWindow()
  
  #mainwindow.showMaximized()
  
  scripts = {}
  
  config = yaml_to_namespaces(yaml.load(open(os.path.join(qttircpath, "qttirc.conf")))) #todo: allow to specify config and performs in command-line options
#  for line in open(os.path.join(qttircpath, "performonstartup.txt")): #should we make perform scripts more like scripts in the scripts directory to give them programmability?
#    line = line.rstrip()
#    docommand("serverwindow", serverwindow, line)
    
  networks = []
  font = QFont(config.font or "Fixedsys", config.font_size or 16) #fixedsys only goes up to 9?
  serverwindow = ServerWindow(network=None)
  serverwindows.append(serverwindow)  
    
  reactor.run()

if __name__=="__main__":
  for name in dir(ServerConnection):
    if not name.startswith('_'):
      obj = getattr(ServerConnection, name)
      if callable(obj):
        setattr(ServerConnection, name, makefunc(name, obj))

  for command in config.performonstartup:
    docommand("serverwindow", serverwindow, command)

  identf = runidentd() #todo: set ident in config file. also warn if can't open port for listening. 
